[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Prashant Mudgal",
    "section": "",
    "text": "In this blog, I am documenting my learning journey in quantum computing and quantum mechanics.\nI am mainly writing for myself, trying to explain/clarify concepts to myself while writing and crystallising them for future use too.\nThrough this blog, I am implementing the concept of ‚ÄúThe Best Way to Learn s to Teach‚Äù.\nIf you stumbled across this blog and you find it useful, then that‚Äôs destiny :)"
  },
  {
    "objectID": "posts/Dirac/lab1.html",
    "href": "posts/Dirac/lab1.html",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "",
    "text": "Getting started with Dirac notation and qiskit circuits."
  },
  {
    "objectID": "posts/Dirac/lab1.html#vectors-and-dirac-notation",
    "href": "posts/Dirac/lab1.html#vectors-and-dirac-notation",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Vectors and Dirac Notation",
    "text": "Vectors and Dirac Notation\nIn the lectures you learned different ways of representing quantum states, including how to use bra-ket (Dirac) notation.\nAlthough bra-ket notation cannot be represented exactly in code, we can represent their vector and matrix equivalent with python.\nE.g. we can represent \\(|0\\rangle\\) using a python list:\n\nket0 = [[1],[0]]\n\nAnd we can use one of Qiskit‚Äôs visualisation tools to make our vectors nicer to look at:\n\narray_to_latex(ket0)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can do the same with \\(\\langle0|\\):\n\nbra0 = [1,0]\narray_to_latex(bra0)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 1 - create \\(|1\\rangle\\) and \\(\\langle1|\\) with python lists\n\n\nket1 = [[0], [1]]\nbra1 = [0 , 1]\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex1 \n\ngrade_lab1_ex1([ket1, bra1])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#qiskit-statevector-class",
    "href": "posts/Dirac/lab1.html#qiskit-statevector-class",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Qiskit Statevector Class",
    "text": "Qiskit Statevector Class\nIn the lectures you learned about using state vectors to represent quantum states. You can represent quantum state vectors in code using Qiskit‚Äôs Statevector class.\nQiskit‚Äôs Statevector class can take different forms of input (e.g.¬†python list, numpy array, another state vector) to construct a state vector.\nLet‚Äôs take the bra0 object we created earlier and convert it to a Statevector object:\n\nsv_bra0 = Statevector(bra0)\n\nsv_bra0\n\nStatevector([1.+0.j, 0.+0.j],\n            dims=(2,))\n\n\nThe Statevector class has its own draw() method:\n\nsv_bra0.draw('latex')\n\n\\[ |0\\rangle\\]\n\n\nWe can create more complex statevectors with multiple qubits like this:\n\nsv_eq = Statevector([1/2, 3/4, 4/5, 6/8])\n\nsv_eq.draw('latex')\n\n\\[\\frac{1}{2} |00\\rangle+\\frac{3}{4} |01\\rangle+\\frac{4}{5} |10\\rangle+\\frac{3}{4} |11\\rangle\\]\n\n\nNote that the vector above is not a valid state vector as it is not normalised. We can check this with the is_valid() method:\n\nsv_eq.is_valid()\n\nFalse\n\n\n\nEx 2 - create your own valid statevector object using the Statevector class\n\n\nsv_valid = Statevector([1/2, 1/2, 1/2, 1/2])\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex2 \n\ngrade_lab1_ex2(sv_valid)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#qiskit-operator-class",
    "href": "posts/Dirac/lab1.html#qiskit-operator-class",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Qiskit Operator Class",
    "text": "Qiskit Operator Class\nThe Operator class is used in Qiskit to represent matrix operators acting on a quantum system. It has several methods to build composite operators using tensor products of smaller operators, and to compose operators.\nOne way we can initialise a Qiskit Operator is by using a python list, like the one we created earlier:\n\nop_bra0 = Operator(bra0)\n\nop_bra0\n\nOperator([1.+0.j, 0.+0.j],\n         input_dims=(), output_dims=(2,))\n\n\nThe Operator class comes with some handy methods for working with operators, for example we can find the tensor product of 2 operators by using the tensor() method:\n\nop_ket0 = Operator(ket0)\nop_bra0.tensor(op_ket0)\n\nOperator([[1.+0.j, 0.+0.j],\n          [0.+0.j, 0.+0.j]],\n         input_dims=(), output_dims=(2, 2))\n\n\n\nop_ket0\n\nOperator([[1.+0.j],\n          [0.+0.j]],\n         input_dims=(), output_dims=(2,))\n\n\n\nop_ket0.tensor(op_bra0)\n\nOperator([[1.+0.j, 0.+0.j],\n          [0.+0.j, 0.+0.j]],\n         input_dims=(), output_dims=(2, 2))\n\n\nWe‚Äôll use the Operator and Statevector classes more in the following exercises."
  },
  {
    "objectID": "posts/Dirac/lab1.html#inner-outer-product",
    "href": "posts/Dirac/lab1.html#inner-outer-product",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Inner & Outer Product",
    "text": "Inner & Outer Product\nIn the lectures you covered the concepts of the inner and outer product. We can explore these concepts in code using numpy methods .dot() (the inner product is a generalised form of the dot product) and .outer().\nFor example, we can find the inner product \\(\\langle0|0\\rangle\\) like this:\n\nbraket = np.dot(op_bra0,op_ket0)\narray_to_latex(braket)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nand the outer product \\(|0\\rangle\\langle0|\\) like this:\n\nketbra = np.outer(ket0,bra0)\narray_to_latex(ketbra)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nbraket = np.dot(op_bra0,op_ket0)\narray_to_latex(braket)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nNote: the numpy methods we used above work with Qiskit Operators as well as regular python lists.\n\nEx 3 - use numpy to find the result of the following inner and outer products: \\(\\langle1|0\\rangle, \\langle0|1\\rangle, \\langle1|1\\rangle, |1\\rangle\\langle0|, |0\\rangle\\langle1|\\) and $|1| $\n\n\nbra1ket0 = np.dot(bra1,ket0)# put your answer for ‚ü®1|0‚ü© here\n\nbra0ket1 = np.dot(bra0,ket1)# put your answer for ‚ü®0|1‚ü© here\n\nbra1ket1 = np.dot(bra1,ket1)# put your answer for ‚ü®1|1‚ü© here\n\nket1bra0 = np.outer(ket1,bra0)# put your answer for |1‚ü©‚ü®0| here\n\nket0bra1 = np.outer(ket0,bra1) # put your answer for |0‚ü©‚ü®1| here\n\nket1bra1 = np.outer(ket1,bra1)# put your answer for |1‚ü©‚ü®1| here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex3 \n\ngrade_lab1_ex3([bra1ket0, bra0ket1, bra1ket1, ket1bra0, ket0bra1, ket1bra1])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nnp.dot(ket1, ket1)\n\nTraceback (most recent call last):\n  Cell In[30], line 1\n    np.dot(ket1, ket1)\n  File &lt;__array_function__ internals&gt;:180 in dot\nValueError: shapes (2,1) and (2,1) not aligned: 1 (dim 1) != 2 (dim 0)\n\nUse %tb to get the full traceback.\n\n\n\n\nSearch for solution online\n\n\n\n&lt;p&gt; Ex 4 - when the inner product of 2 quantum states is equal to 0, those states are orthogonal. Which of the following states are orthogonal? &lt;/p&gt;\n&lt;p&gt;a) $\\vert 0\\rangle$ and $\\vert 1\\rangle$ &lt;/p&gt;\n&lt;p&gt;b) $\\vert 0\\rangle$ and $\\vert 0\\rangle$ &lt;/p&gt;\n&lt;p&gt;c) $\\vert 1\\rangle$ and $\\vert 1\\rangle$ &lt;/p&gt;\n\n\n# add or remove your answer from this list\nanswer = ['a']\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex4 \n\ngrade_lab1_ex4(answer)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#deterministic-operations",
    "href": "posts/Dirac/lab1.html#deterministic-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Deterministic operations",
    "text": "Deterministic operations\nAs mentioned in the lectures, there are 4 single bit deterministic operations:\nf1 = constant-0\nf2 = identity\nf3 = bit flip / not\nf4 = constant-1\n\\[\n\\begin{array}{c|c}\n  a & f_1(a)\\\\\n  \\hline\n  0 & 0\\\\\n  1 & 0\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_2(a)\\\\\n  \\hline\n  0 & 0\\\\\n  1 & 1\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_3(a)\\\\\n  \\hline\n  0 & 1\\\\\n  1 & 0\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_4(a)\\\\\n  \\hline\n  0 & 1\\\\\n  1 & 1\n\\end{array}\n\\]\nWe can create Qiskit Operators for these 4 operations, by passing their matrix representations as arguments to the Operator class.\nE.g. for constant-0 we can create the corresponding matrix m1 like so:\n\nm1 = Operator([[1,1],[0,0]])\narray_to_latex(m1)\n\n$$\n\\[\\begin{bmatrix}\n1 & 1  \\\\\n0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nand similarly for m3:\n\nm3 = Operator([[0,1],[1,0]])\narray_to_latex(m3)\n\n$$\n\\[\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can also use builtin python mutliplication operations (e.g.¬†@, .dot, or .matmul) to check the following equation: $ M|a= f|a$\ne.g.¬†$ M1|0= f1|0$ = 0\n\narray_to_latex(m1@ket0)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 5 - create Qiskit Operators for m2 and m4 (hint: check out the lectures to find the appropriate matrices)\n\n\nm2 =  Operator([[1,0],[0,1]]) # create an operator for m2 here\nm4 =  Operator([[0,0],[1,1]])# create and operator for m4 here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex5\n\ngrade_lab1_ex5([m2, m4])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#probabilistic-operations",
    "href": "posts/Dirac/lab1.html#probabilistic-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Probabilistic operations",
    "text": "Probabilistic operations\nA Controlled-NOT (or CNOT) operation is a probabilistic operation you can apply on 2 qubits.\nApplying a CNOT on a state (X,Y) involves performing a NOT operation on Y when X is 1, otherwise do nothing. X is the control bit, Y is the target bit.\nWe can implement a CNOT gate (and many other quantum gates) using a class from Qiskit‚Äôs circuit library:\n\ncnot = CXGate()\n\narray_to_latex(cnot)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0 & 0 & 0  \\\\\n0 & 0 & 0 & 1  \\\\\n0 & 0 & 1 & 0  \\\\\n0 & 1 & 0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nNote: this matrix is different from the one that appeared in the lesson because CXGate() takes the right qubit to be the control rather than the left qubit."
  },
  {
    "objectID": "posts/Dirac/lab1.html#unitary-operations",
    "href": "posts/Dirac/lab1.html#unitary-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Unitary Operations",
    "text": "Unitary Operations\nAn operator is unitary if: $ UU^{} = = U^{} U$\nWe can check if an operator is Unitary using Qiskit with the is_unitary() method:\n\nm3.is_unitary()\n\nTrue\n\n\nWith small operators like m3 we could probably figure this out easily by ourselves, but with more complex operators it becomes more convenient to use the Qiskit function:\n\nrandom = Operator(np.array([[ 0.50778085-0.44607116j, -0.1523741 +0.14128434j,  0.44607116+0.50778085j,\n  -0.14128434-0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j, -0.12151822+0.16855994j,\n  -0.38038841+0.55868196j],\n [ 0.50778085-0.44607116j, -0.1523741 +0.14128434j, -0.44607116-0.50778085j,\n   0.14128434+0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j,  0.12151822-0.16855994j,\n   0.38038841-0.55868196j]]))\n\nrandom.is_unitary()\n\nTrue\n\n\n\nEx 6 - create an operator using the Operator class that is not unitary\n\n\nnon_unitary_op = Operator(np.array([[ 0.52778085-0.49607116j, -0.1523741 +0.14128434j,  0.44607116+0.50778085j,\n  -0.14128434-0.1523741j ],\n [ 0.16855994+0.17151822j,  0.55868196+0.38038841j, -0.12151822+0.16855994j,\n  -0.38038841+0.55868196j],\n [ 0.50778085-0.44607116j, -0.1523741 +0.14128434j, -0.44607116-0.50778085j,\n   0.14128434+0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j,  0.12151822-0.16855994j,\n   0.38038841-0.55868196j]]))# create your operator here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex6\n\ngrade_lab1_ex6(non_unitary_op)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nQubit Unitary Operations - Pauli Operations\nSome of the most common unitary operations in quantum computing are the Pauli operations. Qiskit‚Äôs Pauli classes make it easy to interact with Pauli operators in code:\nE.g. Pauli X (\\(\\sigma_x\\)), the bit flip:\n\npauli_x = Pauli('X')\n\narray_to_latex(pauli_x)\n\n$$\n\\[\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nPauli Y (\\(\\sigma_y\\)):\n\npauli_y = Pauli('Y')\n\narray_to_latex(pauli_y)\n\n$$\n\\[\\begin{bmatrix}\n0 & - i  \\\\\ni & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nPauli Z (\\(\\sigma_z\\)), the phase flip:\n\npauli_z = Pauli('Z')\n\narray_to_latex(pauli_z)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n0 & -1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can use the Operator class with the Pauli class:\n\nop_x = Operator(pauli_x)\n\nop_x\n\nOperator([[0.+0.j, 1.+0.j],\n          [1.+0.j, 0.+0.j]],\n         input_dims=(2,), output_dims=(2,))\n\n\nLet‚Äôs use the Operator class and numpy to find the outcome of \\(\\sigma_x|0\\rangle\\)\n\nop_new = np.dot(op_x,ket0)\n\narray_to_latex(op_new)\n\n$$\n\\[\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nop_z = Operator(pauli_z)\n\nop_z\n\nOperator([[ 1.+0.j,  0.+0.j],\n          [ 0.+0.j, -1.+0.j]],\n         input_dims=(2,), output_dims=(2,))\n\n\n\nEx 7 - Apply the Pauli-Z operator on \\(|1\\rangle\\)\n\n\nresult = np.dot(op_z, ket1) # do your operations here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex7\n\ngrade_lab1_ex7(result)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\n\nQubit Unitary Operations - Hadamard\nThe Hadamard gate is one of the most important unitary operations in quantum computing. We can implement a Hadamard gate (and many other quantum gates) using a class from Qiskit‚Äôs circuit library:\n\nhadamard = HGate()\n\narray_to_latex(hadamard)\n\n$$\n\\[\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nYou can convert many Qiskit classes to operators to make use of functions specific to the Operator class, such as is_unitary\n\nhop = Operator(hadamard)\nhop.is_unitary()\n\nTrue"
  },
  {
    "objectID": "posts/Dirac/lab1.html#quantum-circuits",
    "href": "posts/Dirac/lab1.html#quantum-circuits",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Quantum Circuits",
    "text": "Quantum Circuits\nIn the lectures you learned how to create a Quantum Circuit using a CNOT and a Hadamard gate. This circuit creates the Bell State \\(|\\phi^+\\rangle\\). We can implement this using Qiskit‚Äôs QuantumCircuit class:\n\nbell = QuantumCircuit(2)\n\nbell.h(0) # apply an H gate to the circuit\nbell.cx(0,1) # apply a CNOT gate to the circuit\n\nbell.draw(output=\"mpl\")\n\nMatplotlib is building the font cache; this may take a moment.\n\n\n\n\n\nIf we want to check what the matrix representation is of this quantum state we can convert the circuit directly to an operator:\n\nbell_op = Operator(bell)\n\narray_to_latex(bell_op)\n\n$$\n\\[\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2} & 0 & 0  \\\\\n0 & 0 & \\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n0 & 0 & \\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2} & 0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 8 - the GHZ state is similar to the Bell State but applied to 3 qubits. Create a quantum circuit outputting the GHZ state\n\n\nghz = QuantumCircuit(3)\n\n##############################\n# add gates to your circuit here\nghz.h(0)\nghz.cx(0, 1)\nghz.cx(0, 2)\n\n\n\n##############################\n\nghz.draw(output='mpl')\n\n\n\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex8\n\ngrade_lab1_ex8(ghz)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#measuring-quantum-states",
    "href": "posts/Dirac/lab1.html#measuring-quantum-states",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Measuring Quantum states",
    "text": "Measuring Quantum states\nAs explained in the lectures you can find the probability of measurement outcomes by taking the absolute value squared of the entries of a quantum state vector.\nFor example, when measuring the + state:\n$ |+= |0+ |1$\nThe probability of measuring 0 or 1 is given by the following:\n$ Pr(0) = ||^2 = $\n$ Pr(1) = ||^2 = $\nLet‚Äôs create a \\(|+\\rangle\\) using the Statevector class:\n\nplus_state = Statevector.from_label(\"+\")\n\nplus_state.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |0\\rangle+\\frac{\\sqrt{2}}{2} |1\\rangle\\]\n\n\n\nplus_state\n\nStatevector([0.70710678+0.j, 0.70710678+0.j],\n            dims=(2,))\n\n\nNow we can get the probability of measuring 0 or 1:\n\nplus_state.probabilities_dict()\n\n{'0': 0.4999999999999999, '1': 0.4999999999999999}\n\n\nThe dictionary object above shows you all the possible measurement outcomes and what the probability is of getting them. The actual act of measuring forces the state to collapse into either the 0 or 1 state:\n\n# run this cell multiple times to show collapsing into one state or the other\nres = plus_state.measure()\n\nres\n\n('0',\n Statevector([1.+0.j, 0.+0.j],\n             dims=(2,)))\n\n\nWe can implement the same \\(|+\\rangle\\) state with measurement using a quantum circuit:\n\nqc = QuantumCircuit(1,1)\nqc.h(0)\nqc.measure(0, 0)\n\nqc.draw(output=\"mpl\")\n\n\n\n\nIf we ran this circuit using a simulator we would get the same results as we did with the statevector class.\nIn the next example, let‚Äôs use the Statevector class to find the measurement outcomes for a dependent, probabilistic state. We‚Äôll find the measurement probilities for the 2-qubit Bell State \\(|\\phi^+\\rangle\\) :\n\nsv_bell = Statevector([np.sqrt(1/2), 0, 0, np.sqrt(1/2)])\n\nsv_bell.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |00\\rangle+\\frac{\\sqrt{2}}{2} |11\\rangle\\]\n\n\n\nsv_bell.probabilities_dict()\n\n{'00': 0.5000000000000001, '11': 0.5000000000000001}\n\n\n\nEx 9 - Using the Statevector class find the probabilities for the other 3 states in the Bell Basis: \\(|\\psi^+\\rangle\\), \\(|\\psi^-\\rangle\\), \\(|\\phi^-\\rangle\\). Hint: check out lesson 2 to refresh your memory on the equations of the Bell states\n\n\nsv_psi_plus = Statevector([0,np.sqrt(1/2), np.sqrt(1/2), 0])# create a statevector for |ùúì+‚ü© here\nprob_psi_plus =sv_psi_plus.probabilities_dict() # find the measurement probabilities for |ùúì+‚ü© here\n\nsv_psi_minus = Statevector([0,np.sqrt(1/2), -np.sqrt(1/2), 0])# create a statevector for |ùúì‚àí‚ü© here\nprob_psi_minus = sv_psi_minus.probabilities_dict()# find the measurement probabilities for |ùúì‚àí‚ü© here\n\nsv_phi_minus = Statevector([np.sqrt(1/2), 0, 0, -np.sqrt(1/2)])# create a statevector for |ùúô‚àí‚ü© here\nprob_phi_minus = sv_phi_minus.probabilities_dict()# find the measurement probabilities for |ùúô‚àí‚ü© here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex9\n\ngrade_lab1_ex9([prob_psi_plus, prob_psi_minus, prob_phi_minus])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/RNG/14_Random Number Generator.html",
    "href": "posts/RNG/14_Random Number Generator.html",
    "title": "Random Number Generator",
    "section": "",
    "text": "Random number generation using a quantum computer is truly random, it uses superposition principle to generate real random data instead of random-looking periodic sequences."
  },
  {
    "objectID": "posts/RNG/14_Random Number Generator.html#using-quantum-simulator",
    "href": "posts/RNG/14_Random Number Generator.html#using-quantum-simulator",
    "title": "Random Number Generator",
    "section": "Using quantum simulator",
    "text": "Using quantum simulator\n\nimport random\nimport numpy as np\nfrom collections import Counter\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit import BasicAer, execute\n\n\nn = 4\ntrials = 512*n\n\n\nq = QuantumRegister(n)\nc = ClassicalRegister(n)\ncircuit = QuantumCircuit(q, c)\n\n\nfor j in range(n):\n    circuit.h(q[j])\ncircuit.measure(q,c)\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x7fc55d49b310&gt;\n\n\n\ncircuit.draw('mpl')\n\n\n\n\n\njob = execute(circuit, BasicAer.get_backend('qasm_simulator'), shots=trials)\n\n\ncounts = job.result().get_counts()\n\n\ncount_map = {}\nfor ct in counts:\n    count_map[ int(ct,2) ] = counts[ct]/8192\n\nfrom qiskit.tools.visualization import plot_histogram    \nplot_histogram(count_map, figsize = (10,5),color=['crimson'])"
  },
  {
    "objectID": "posts/RNG/14_Random Number Generator.html#using-classical-numpy",
    "href": "posts/RNG/14_Random Number Generator.html#using-classical-numpy",
    "title": "Random Number Generator",
    "section": "Using classical numpy",
    "text": "Using classical numpy\n\nThey are based on deterministic, predictable algorithms and thus not secure\n\nN = 2**n\nrand_lst = []\nfor _ in range(trials):\n    rand_lst.append(np.random.randint(0, N))\n\n\ncounter_rand = Counter(rand_lst)\n\n\ncounter_rand_prob = {}\nfor key,val in counter_rand.items():\n    counter_rand_prob[key] = val/trials\n\n\nplot_histogram(counter_rand_prob, figsize = (10, 5), color=['midnightblue'])"
  },
  {
    "objectID": "posts/RNG/14_Random Number Generator.html#huh-the-distributions-seem-similar-whats-the-hoopla-about",
    "href": "posts/RNG/14_Random Number Generator.html#huh-the-distributions-seem-similar-whats-the-hoopla-about",
    "title": "Random Number Generator",
    "section": "Huh! the distributions seem similar, what‚Äôs the hoopla about?",
    "text": "Huh! the distributions seem similar, what‚Äôs the hoopla about?\nok, here is a paper on random number generator https://shorturl.at/AFMQZ\nThey do a bunch of tests:\n\n\nRestart\n\n\nAutocorrelation\n\n\nNIST statistical tests"
  },
  {
    "objectID": "posts/Coin/Coin Toss.html",
    "href": "posts/Coin/Coin Toss.html",
    "title": "Tossing Quantum Coins and Winning",
    "section": "",
    "text": "How Alice is winning a game of coin flips with a quantum coin?"
  },
  {
    "objectID": "posts/Coin/Coin Toss.html#a-simple-coin-toss",
    "href": "posts/Coin/Coin Toss.html#a-simple-coin-toss",
    "title": "Tossing Quantum Coins and Winning",
    "section": "A simple coin toss",
    "text": "A simple coin toss\n\nimport qiskit\n\n\nfrom qiskit import *\n\n\n# Create circuit with 1 quantum and 1 classical bit\ncircuit = QuantumCircuit(1, 1)\n\n\n# Superposition\ncircuit.h(0)\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x121246320&gt;\n\n\n\n# Measure quantum bit and store result in classical bit\ncircuit.measure(0, 0)\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x121245270&gt;\n\n\n\nqiskit.__qiskit_version__\n\n{'qiskit-terra': '0.24.1', 'qiskit-aer': '0.12.1', 'qiskit-ignis': None, 'qiskit-ibmq-provider': '0.20.2', 'qiskit': '0.43.2', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None}\n\n\n\nfrom qiskit import IBMQ\n\n\nIBMQ.save_account('Put your own unique Token here', overwrite=True)\n\n\nIBMQ.load_account()\n\n&lt;AccountProvider for IBMQ(hub='ibm-q', group='open', project='main')&gt;\n\n\n\ncircuit.draw('mpl')\n\n\n\n\n\n!pip install matplotlib\n\nRequirement already satisfied: matplotlib in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (3.7.2)\nRequirement already satisfied: contourpy&gt;=1.0.1 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (1.1.0)\nRequirement already satisfied: cycler&gt;=0.10 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (0.11.0)\nRequirement already satisfied: fonttools&gt;=4.22.0 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (4.41.0)\nRequirement already satisfied: kiwisolver&gt;=1.0.1 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (1.4.4)\nRequirement already satisfied: numpy&gt;=1.20 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (1.23.5)\nRequirement already satisfied: packaging&gt;=20.0 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (23.1)\nRequirement already satisfied: pillow&gt;=6.2.0 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (10.0.0)\nRequirement already satisfied: pyparsing&lt;3.1,&gt;=2.3.1 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (3.0.9)\nRequirement already satisfied: python-dateutil&gt;=2.7 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from matplotlib) (2.8.2)\nRequirement already satisfied: six&gt;=1.5 in /Users/prashantmudgal/env_q/lib/python3.11/site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib) (1.16.0)\n\n\n\nprovider = IBMQ.get_provider('ibm-q')\n\n\nprovider.backends()\n\n[&lt;IBMQSimulator('ibmq_qasm_simulator') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_lima') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_belem') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_quito') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_statevector') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_mps') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_extended_stabilizer') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_stabilizer') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_jakarta') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_manila') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibm_lagos') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibm_nairobi') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibm_perth') from IBMQ(hub='ibm-q', group='open', project='main')&gt;]\n\n\n\nqcomp = provider.get_backend('ibmq_quito')\n\n\njob = execute(circuit, qcomp, shots=2)\n\n\nfrom qiskit.tools.monitor import job_monitor\n\n\njob_monitor(job)\n\nJob Status: job has successfully run\n\n\n\nimport matplotlib\n%matplotlib inline\n\n\nfrom qiskit.tools.visualization import plot_histogram\n\n\nresult = job.result()\n\n\nresult\n\nResult(backend_name='ibmq_quito', backend_version='1.1.42', qobj_id='0b1fa52f-66d7-4e93-9382-7526a2643f56', job_id='circuit-runner_ciqmqjgs80m10ues9450_fc83_0', success=True, results=[ExperimentResult(shots=2, success=True, meas_level=2, data=ExperimentResultData(counts={'0x0': 1, '0x1': 1}), header=QobjExperimentHeader(clbit_labels=[['c', 0]], creg_sizes=[['c', 1]], global_phase=0.7853981633974483, memory_slots=1, metadata={}, n_qubits=5, name='circuit-133', qreg_sizes=[['q', 5]], qubit_labels=[['q', 0], ['q', 1], ['q', 2], ['q', 3], ['q', 4]]), status=done)], date=2023-07-17 22:36:17+05:30, status=Successful completion, header=QobjHeader(backend_name='ibmq_quito', backend_version='1.1.42', _ibm_tracing_={'uber-trace-id': 'bc3bab6050ad75d80a8c8274aa83050d:7fadaf45e434d3e0:e4c09d084ec71b6:1'}), execution_id='009ddb12-24c4-11ee-86b0-b02628f7f59e', time_taken=1.6188080459999998, error=None, client_version={'qiskit': '0.43.2'})\n\n\n\ncounts = job.result().get_counts()\nresult = \"heads\" if  next(iter(counts.keys())) == \"0\" else \"tails\"\n\n\nThe momemnt of truth: Measure the result of your coin toss on a quantum computer\n\nprint(f\"Your quantum coin landed on: {result}\")\n\nYour quantum coin landed on: heads"
  },
  {
    "objectID": "posts/Coin/Coin Toss.html#how-to-win-a-quantum-coin-flip",
    "href": "posts/Coin/Coin Toss.html#how-to-win-a-quantum-coin-flip",
    "title": "Tossing Quantum Coins and Winning",
    "section": "How to win a quantum coin flip?",
    "text": "How to win a quantum coin flip?\n\n1. Alice prepares her penny in a state in some box where no one can see it\n\n\n2. Bob decides whether he wants to flip the penny, applies X gate or not\n\n\n3. Alice applies any gate (Hadamard)\n\n\n4. We measure that outcome was always the same as the initial state\n\nimport numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Session\n\n\ncircuit = QuantumCircuit(1, 1)\n\n\ncircuit.draw('mpl')\n\n\n\n\n\n\nAlice decides what the initial state of her qubit will be, by default it is 0\n\n# If she wants the initial state to be 1 then she applies x gate\ninit = 1 # make it 0 for state 0\n\nif init == 1:\n    circuit.x(0)\n    \n\n\n\nAlice applies Hadamard gate to create a superposition\n\ncircuit.h(0)\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x12081ead0&gt;\n\n\n\n\nBob decides whether to flip the state of penny that Alice gave to him or leave it as it is\n\n# If he flips then flip = True, otherwise set it to false\nflip = True\n\nif flip == True:\n    circuit.x(0)\n\n\n\nAlice applies Hadamard gate\n\ncircuit.h(0)\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x12081e5f0&gt;\n\n\n\ncircuit.measure(0,0)\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x12081efe0&gt;\n\n\n\ncircuit.draw('mpl')\n\n\n\n\n\nprovider.backends()\n\n[&lt;IBMQSimulator('ibmq_qasm_simulator') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_lima') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_belem') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_quito') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_statevector') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_mps') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_extended_stabilizer') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQSimulator('simulator_stabilizer') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_jakarta') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibmq_manila') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibm_lagos') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibm_nairobi') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,\n &lt;IBMQBackend('ibm_perth') from IBMQ(hub='ibm-q', group='open', project='main')&gt;]\n\n\n\nqcomp = provider.get_backend('ibmq_qasm_simulator')\n\n\njob = execute(circuit, qcomp, shots=1)\n\n\nfrom qiskit.tools.monitor import job_monitor\n\n\njob_monitor(job)\n\nJob Status: job has successfully run\n\n\n\nresult = job.result()\n\n\ncounts = job.result().get_counts()\ncounts\n\n{'1': 1}\n\n\n\n\n\ncointossbloch.png\n\n\n\n\n\ncointossprob.png\n\n\n\nfin_result = 0 if  next(iter(counts.keys())) == \"0\" else 1"
  },
  {
    "objectID": "posts/Teleport/Teleportation.html",
    "href": "posts/Teleport/Teleportation.html",
    "title": "Quantum Teleportation",
    "section": "",
    "text": "How Quantum qubits can be teleported despite No Cloning Theorem?\n\nTeleportation\nQuantum information cannot be copied due to the No Cloning Theorem, however it can be ‚Äúteleported‚Äù in the sense that a qubit can be entangled with a quantum resource, and via a protocol of measurements and classical communication of their results, the original quantum state can be reconstructed on a different qubit. This process destroys the information in the original qubit via measurement.\nIn this exercise, we will construct a particular qubit state and then transfer that state to another qubit using the teleportation protocol. Here we will be looking at specific classical and quantum registers, so we need to import those.\n\nfrom qiskit.circuit import ClassicalRegister, QuantumRegister\nfrom qiskit.circuit import Parameter\nfrom qiskit.circuit import QuantumCircuit\n\n\nCreate the circuit\nDefine an angle \\(\\theta\\) to rotate our qubit by. This will allow us to easily make comparisons for the original state and the teleported state.\n\ntheta = Parameter('Œ∏')\n\nqr = QuantumRegister(1, 'q')\nqc = QuantumCircuit(qr)\nqc.ry(theta, 0)\nqc.draw('mpl')\n\n\n\n\nAlice possesses the quantum information \\(|\\psi\\rangle\\) in the state of \\(q\\) and wishes to transfer it to Bob. The resource they share is a special entangled state called a Bell state \\[\n|\\Phi^+\\rangle = \\frac{1}{2} \\left( |00\\rangle + |11\\rangle \\right)\n\\] with the first of the pair going to Alice and the second to Bob. Hence Alice has a 2-qubit register (\\(q\\) and \\(Bell_0\\)) and Bob has a single-qubit register (\\(Bell_1\\)). We will construct the circuit by copying the original qc and adding the appropriate registers.\n\ntele_qc = qc.copy()\nbell = QuantumRegister(2, 'Bell')\nalice = ClassicalRegister(2, 'Alice')\nbob = ClassicalRegister(1, 'Bob')\ntele_qc.add_register(bell, alice, bob)\ntele_qc.draw('mpl')\n\n\n\n\nNow create the Bell pair with \\(Bell_0\\) going to Alice and \\(Bell_1\\) going to Bob. This is done by using a Hadamard gate to put \\(Bell_0\\) in the \\(|+\\rangle\\) state and then performing a CNOT with the same qubit as the control. After they receive their respective qubit, they part ways.\n\n# create Bell state with other two qubits\ntele_qc.barrier()\ntele_qc.h(1)\ntele_qc.cx(1, 2)\ntele_qc.barrier()\ntele_qc.draw('mpl')\n\n\n\n\nNext, Alice performs a CNOT controlled by \\(q\\) on \\(Bell_0\\), which maps information about the state onto it. She then applies a Hadamard gate on \\(q\\).\n\n# alice operates on her qubits\ntele_qc.cx(0, 1)\ntele_qc.h(0)\ntele_qc.barrier()\ntele_qc.draw('mpl')\n\n\n\n\nNow Alice measures her qubits and saves the results to her register.\n\n ty= ClassicalRegister(2, 'alpha')\n\n\nty[0]\n\nClbit(ClassicalRegister(2, 'alpha'), 0)\n\n\n\nty[1]\n\nClbit(ClassicalRegister(2, 'alpha'), 1)\n\n\n\ntele_qc.measure([qr[0], bell[0]], alice)\ntele_qc.draw('mpl')\n\n\n\n\nBob‚Äôs qubit now has the information \\(|\\psi\\rangle\\) from Alice‚Äôs qubit \\(q\\) encoded in \\(Bell_1\\), but he does not know what basis to measure in to extract it. Accordingly, Alice must share the information in her register over a classical communication channel (this is why teleportation does not violate special relativity, no matter how far Alice and Bob are apart). She instructs Bob to perform an X gate on his qubit if her measurement of \\(Bell_0\\) yields a 1 outcome, followed by a Z gate if her measurement of \\(q\\) yields a 1.\nThe applications of these gates can be conditioned on the measurement outcomes in two ways: - the .c_if() instruction, which applies the gate it modifies if the value of the ClassicalRegister index is equal to the value specified. Note that this works only on simulators. - the .if_test() context which operates similarly, but generalizes the syntax to allow for nested conditionals. This works on both simulators and actual hardware.\n\nbell[0]\n\nQubit(QuantumRegister(2, 'Bell'), 0)\n\n\n\nqr[0]\n\nQubit(QuantumRegister(1, 'q'), 0)\n\n\n\ndef bob_transform(qc, bob_bit, alice):\n    qc.x(bob_bit).c_if(alice[1], 1)\n    qc.z(bob_bit).c_if(alice[0], 1)\n\n\ngraded_qc = tele_qc.copy()\ngraded_qc.barrier()\nbob_transform(graded_qc, bell[1], alice)\n\n\ngraded_qc.draw('mpl')\n\n\n\n\nFinally, Bob can measure his qubit, which would yield results with the same probabilities as had Alice measured it originally.\n\ngraded_qc.barrier()\ngraded_qc.measure(bell[1], bob)\ngraded_qc.draw('mpl')\n\n\n\n\nThe statevector simulator cannot work with dynamic circuits because measurement is not a unitary operation. Therefore we import the Sampler primitive from qiskit_aer to use the AerSimulator. We choose our angle to be \\(5\\pi/7\\), which will yield a 1 result about 80% of the time and 0 result about 20% of the time. Then we run both circuits: the original one Alice had and the teleported one Bob receives.\n\nfrom qiskit_aer.primitives import Sampler\nimport numpy as np\n\nangle = 5*np.pi/7\n\nsampler = Sampler()\nqc.measure_all()\njob_static = sampler.run(qc.bind_parameters({theta: angle}))\njob_dynamic = sampler.run(graded_qc.bind_parameters({theta: angle}))\n\nprint(f\"Original Dists: {job_static.result().quasi_dists[0].binary_probabilities()}\")\nprint(f\"Teleported Dists: {job_dynamic.result().quasi_dists[0].binary_probabilities()}\")\n\nOriginal Dists: {'1': 0.806640625, '0': 0.193359375}\nTeleported Dists: {'011': 0.03515625, '111': 0.2001953125, '001': 0.05078125, '110': 0.1826171875, '100': 0.208984375, '101': 0.2431640625, '000': 0.0341796875, '010': 0.044921875}\n\n\nWait, we see different results! While measuring Alice‚Äôs original \\(q\\) yields the expected ratio of outcomes, the teleported distributions have many more values. This is because the teleported circuit includes Alice‚Äôs measurements of \\(q\\) and \\(Bell_0\\), whereas we only wish to see Bob‚Äôs measurements of \\(Bell_1\\) yield the same distribution.\nIn order to rectify this, we must take the marginal counts, meaning we combine results in which Bob measures a 0 and all the results in which Bob measures a 1 over all the possible combinations. This is done with the marginal_counts method from qiskit.result, which combines results over measurement indices.\n\n\nMarginalisation\nEx 4 - Marginalize the teleported counts\nHint: Remember that bit strings are reported in the little-endian convention.\n\njob_static.result().quasi_dists[0]\n\n{1: 0.806640625, 0: 0.193359375}\n\n\n\njob_static.result()\n\nSamplerResult(quasi_dists=[{1: 0.806640625, 0: 0.193359375}], metadata=[{'shots': 1024, 'simulator_metadata': {'parallel_state_update': 12, 'parallel_shots': 1, 'sample_measure_time': 0.000272645, 'noise': 'ideal', 'batched_shots_optimization': False, 'remapped_qubits': False, 'device': 'CPU', 'active_input_qubits': [0], 'measure_sampling': True, 'num_clbits': 1, 'input_qubit_map': [[0, 0]], 'num_qubits': 1, 'method': 'statevector', 'fusion': {'applied': False, 'max_fused_qubits': 5, 'threshold': 14, 'enabled': True}}}])\n\n\n\nresult_dynamic = job_dynamic.result().quasi_dists[0].binary_probabilities()\n\n\nprint(result_dynamic)\n\n{'011': 0.03515625, '111': 0.2001953125, '001': 0.05078125, '110': 0.1826171875, '100': 0.208984375, '101': 0.2431640625, '000': 0.0341796875, '010': 0.044921875}\n\n\n\n## Index should be 2 because we want to measure Bob's bit, left most bit e.g. in 100, Bob's bit is 1\nfrom qiskit.result import marginal_counts\n\n\ntele_counts = marginal_counts(result_dynamic, indices=[2])# marginalize counts\n\n\ntele_counts\n\n{'0': 0.1650390625, '1': 0.8349609375}\n\n\n\nfrom qiskit.visualization import plot_histogram\nlegend = ['Original State', 'Teleported State']\nplot_histogram([job_static.result().quasi_dists[0].binary_probabilities(), tele_counts], legend=legend)\n\n\n\n\n\nimport qiskit.tools.jupyter\n%qiskit_version_table\n\nVersion Information\n\n\n\nQiskit Software\nVersion\n\n\nqiskit-terra\n0.24.0\n\n\nqiskit-aer\n0.12.0\n\n\nqiskit-ibmq-provider\n0.20.2\n\n\nqiskit\n0.43.0\n\n\nSystem information\n\n\n\nPython version\n3.8.3\n\n\nPython compiler\nClang 10.0.0\n\n\nPython build\ndefault, Jul 2 2020 11:26:31\n\n\nOS\nDarwin\n\n\nCPUs\n6\n\n\nMemory (Gb)\n16.0\n\n\nSat Jul 22 22:53:52 2023 IST"
  },
  {
    "objectID": "posts/Heisenberg_Explain/index.html",
    "href": "posts/Heisenberg_Explain/index.html",
    "title": "Explanation of Heisenberg‚Äôs Uncertainty Principle",
    "section": "",
    "text": "How does the uncertainty arise in the measurements and calculations for quantum particles?\nThe explanation lies in the change of basis and the incompatible Pauli quantum operators."
  },
  {
    "objectID": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html",
    "href": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html",
    "title": "Heisenberg‚Äôs Uncertainty Principle",
    "section": "",
    "text": "What did Heisenberg really mean by the uncertainty principle?\nThe most popular form of the uncertainty principle is about position and momentum of a particule, if one is know the other is uncertain; We will examine the same but not the momentum and position but using different basis of measures.\nfrom qiskit import QuantumCircuit, assemble, Aer\nfrom math import pi, sqrt\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nsim = Aer.get_backend('aer_simulator')\n# Let's do an X-gate on a |0&gt; qubit\nqc = QuantumCircuit(1)\nqc.x(0)\nqc.draw()\n\n   ‚îå‚îÄ‚îÄ‚îÄ‚îê\nq: ‚î§ X ‚îú\n   ‚îî‚îÄ‚îÄ‚îÄ‚îò\n# Let's see the result\nqc.save_statevector()\nstate = sim.run(qc).result().get_statevector()\nplot_bloch_multivector(state)\nThe state hs been changed from 0 to 1, thats what X gate does\nqc.y(0) # Do Y-gate on qubit 0\nqc.z(0) # Do Z-gate on qubit 0\nqc.draw()\n\n   ‚îå‚îÄ‚îÄ‚îÄ‚îê statevector ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê\nq: ‚î§ X ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ Y ‚îú‚î§ Z ‚îú\n   ‚îî‚îÄ‚îÄ‚îÄ‚îò      ‚ñë      ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò\n# Create the X-measurement function:\ndef x_measurement(qc, qubit, cbit):\n    \"\"\"Measure 'qubit' in the X-basis, and store the result in 'cbit'\"\"\"\n    qc.h(qubit)\n    qc.measure(qubit, cbit)\n    return qc\n\ninitial_state = [1/sqrt(2), -1/sqrt(2)]\n# Initialize our qubit and measure it\nqc = QuantumCircuit(1,1)\nqc.initialize(initial_state, 0)\nx_measurement(qc, 0, 0)  # measure qubit 0 to classical bit 0\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ Initialize(0.70711,-0.70711) ‚îú‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                                           0\ncounts = sim.run(qc).result().get_counts()  # Do the simulation, returning the state vector\nplot_histogram(counts)  # Display the output on measurement of state vector\nWe initialized our qubit in - the state , but we can see that, after the measurement, we have collapsed our qubit to the 1 state . If you run the cell again, you will see the same result, since along the X-basis, the state - is a basis state and measuring it along X will always yield the same result.\nMeasuring in different bases allows us to see Heisenberg‚Äôs famous uncertainty principle in action. Having certainty of measuring a state in the Z-basis removes all certainty of measuring a specific state in the X-basis, and vice versa. A common misconception is that the uncertainty is due to the limits in our equipment, but here we can see the uncertainty is actually part of the nature of the qubit."
  },
  {
    "objectID": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html#heisenbergs-uncertainty-principle",
    "href": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html#heisenbergs-uncertainty-principle",
    "title": "Heisenberg‚Äôs Uncertainty Principle",
    "section": "Heisenberg‚Äôs Uncertainty principle",
    "text": "Heisenberg‚Äôs Uncertainty principle\nhttps://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-states/old-unique-properties-qubits.ipynb\n\nfrom qiskit import *\nfrom qiskit.visualization import plot_histogram\n%config InlineBackend.figure_format = 'svg' # Makes the images look nice\n\n\nmeasure_z = QuantumCircuit(1,1)\nmeasure_z.measure(0,0)\n\nmeasure_z.draw(output='mpl')\n\n\n\n\n\nmeasure_x = QuantumCircuit(1,1)\nmeasure_x.h(0)\nmeasure_x.measure(0,0)\n\nmeasure_x.draw(output='mpl')\n\n\n\n\n\nqc_0 = QuantumCircuit(1)\n\nqc_0.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_z, qc_0)\n\nqc.draw()\n\n     ‚îå‚îÄ‚îê\n  q: ‚î§M‚îú\n     ‚îî‚ï•‚îò\nc: 1/‚ïê‚ï©‚ïê\n      0 \n\n\n\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\n\n\ncounts\n\n{'0': 1024}\n\n\n\nprint('Results for z measurement:')\n\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_x, qc_0)\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n           0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\n\nqc_plus = QuantumCircuit(1)\nqc_plus.h(0)\n\nqc_plus.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_z)\n\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n           0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ H ‚îú‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two.\n\nOther rotations\n\nqc_y = QuantumCircuit(1)\nqc_y.ry( -3.14159/4,0)\n\nqc_y.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_y, measure_z)\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ Ry(-0.7854) ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                     0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\nHere we have a case that we have not seen before. The z measurement is most likely to output 0, but it is not completely certain. A similar effect is seen below for the x measurement: it is most likely, but not certain, to output 1.\n\nqc = QuantumCircuit.compose(qc_y, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ Ry(-0.7854) ‚îú‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                          0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two."
  },
  {
    "objectID": "posts/CHSH/CHSH.html",
    "href": "posts/CHSH/CHSH.html",
    "title": "Nobel Prize for Physics in 2022",
    "section": "",
    "text": "How local reality doesn‚Äôt hold true for quantum mechanics!\nThe historical development of quantum mechanics is filled with agitated discussions about the true nature of reality and the extent to which quantum mechanics can explain it. Given the spectacular empirical success of quantum mechanics, it was going to be clear that people would not simply give it up just because some of its aspects were hard to reconcile with intuition.\nAt the root of these different points of views was the question of the nature of measurement. We know there is an element of randomness in quantum measurements, but is that really so? Is there a sneaky way by which the Universe has already decided beforehand which value a given measurement is going to yield at a future time? This hypothesis was the basis for different hidden variable theories. But these theories did not only need to explain randomness at the single particle level. They also needed to explain what happens when different observers measure different parts of a multi-partite entangled system! This went beyond just hidden variable theories. Now a local hidden variable theory was needed in order to reconcile the observations of quantum mechanics with a Universe in which local reality was valid.\nWhat is local reality? In an Universe where locality holds, it should be possible to separate two systems so far in space that they could not interact with each other. The concept of reality is related to whether a measurable quantity holds a particular value in the absence of any future measurement.\nIn 1963, John Stewart Bell published what could be argued as one of the most profound discoveries in the history of science. Bell stated that any theory invoking local hidden variables could be experimentally ruled out. In this section we are going to see how, and we will run a real experiment that demonstrates so! (with some remaining loopholes to close‚Ä¶)\nIt‚Äôs an experiment on a quantum computer to demonstrate the violation of the CHSH inequality with the Estimator primitive.\nThe violation of the CHSH inequality is used to show that quantum mechanics is incompatible with local hidden-variable theories. This is an important experiment for understanding the foundation of quantum mechanics. The 2022 Nobel Prize for Physics was awarded to Alain Aspect, John Clauser and Anton Zeilinger for their pioneering work in quantum information science, and in particular, their experiments with entangled photons demonstrating violation of Bell‚Äôs inequalities. An experimental method by which one can test Bell‚Äôs inequality was put forth by Clauser, Horne, Shimony, and Holt (CHSH) in 1969, and forms the basis for the experiment conducted here."
  },
  {
    "objectID": "posts/CHSH/CHSH.html#chsh-inequality",
    "href": "posts/CHSH/CHSH.html#chsh-inequality",
    "title": "Nobel Prize for Physics in 2022",
    "section": "CHSH Inequality",
    "text": "CHSH Inequality\nImagine Alice and Bob are given each one part of a bipartite entangled system. Each of them then performs two measurements on their part in two different bases. Let‚Äôs call Alice‚Äôs bases A and a and Bob‚Äôs B and b. What is the expectation value of the quantity\n\\[\n\\langle CHSH \\rangle = \\langle AB \\rangle - \\langle Ab \\rangle + \\langle aB \\rangle + \\langle ab \\rangle ?\n\\]\nNow, Alice and Bob have one qubit each, so any measurement they perform on their system (qubit) can only yield one of two possible outcomes: +1 or -1. Note that whereas we typically refer to the two qubit states as \\(|0\\rangle\\) and \\(|1\\rangle\\), these are eigenstates, and a projective measurement will yield their eigenvalues, +1 and -1, respectively.\nTherefore, if any measurement of A, a, B, and b can only yield \\(\\pm 1\\), the quantities \\((B-b)\\) and \\((B+b)\\) can only be 0 or \\(\\pm 2\\). And thus, the quantity \\(A(B-b) + a(B+b)\\) can only be either +2 or -2, which means that there should be a bound for the expectation value of the quantity we have called\n\\[\n|\\langle CHSH \\rangle| = |\\langle AB \\rangle - \\langle Ab \\rangle + \\langle aB \\rangle + \\langle ab \\rangle| \\le 2.\n\\]\n\nIf quantum mechanics can be described by local hidden variable theories, the previous inequalities must hold true.\n\nimport numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit import Parameter\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Session\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as tck\n\n\n\nCreate Entangled Qubit Pair\nNext we want to test the \\(CHSH\\) observable on an entangled pair, for example the maximally-entangled Bell state \\[\n|\\Phi\\rangle = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle \\right)\n\\] which is created with a Hadamard gate followed by a CNOT with the target on the same qubit as the Hadamard. Due to the simplifaction of measuring in just the \\(X\\)- and \\(Z\\)-bases as discussed above, we will rotate the Bell state around the Bloch sphere which is equivalant to changing the measurement basis. This can be done by applying an \\(R_y(\\theta)\\) gate where \\(\\theta\\) is a Parameter to be specified at the Estimator API call. This produces the state \\[\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}} \\left(\\cos(\\theta/2) |00\\rangle + \\sin(\\theta/2)|11\\rangle \\right)\n\\]\n\ntheta = Parameter(\"$\\\\theta$\")\n\nchsh_circuits_no_meas = QuantumCircuit(2)\nchsh_circuits_no_meas.h(0)\nchsh_circuits_no_meas.cx(0, 1)\nchsh_circuits_no_meas.ry(theta, 0)\nchsh_circuits_no_meas.draw(\"mpl\")\n\n\n\n\nNext we need to specify a Sequence of Parameters that show a clear violation of the CHSH Inequality, namely \\[\n|\\langle CHSH \\rangle| &gt; 2.\n\\]\nWe will analyze the results and plot them against the measurement angle and will see that for certain range of measurement angles, the expectation values of CHSH quantities or, which demonstrates the violation of the CHSH inequality.\n\nnumber_of_phases = 21\nphases = np.linspace(0, 2 * np.pi, number_of_phases)\n# Phases need to be expressed as list of lists in order to work\nindividual_phases = [[ph] for ph in phases]\n\n\nservice = QiskitRuntimeService()\nbackend=\"ibmq_qasm_simulator\" #service.get_backend(\"ibmq_manila\")\n\n\nZZ = SparsePauliOp.from_list([(\"ZZ\", 1)])\nZX = SparsePauliOp.from_list([(\"ZX\", 1)])\nXZ = SparsePauliOp.from_list([(\"XZ\", 1)])\nXX = SparsePauliOp.from_list([(\"XX\", 1)])\n\nops = [ZZ, ZX, XZ, XX]\nchsh_est = []\n\n# Simulator\nwith Session(backend=backend):\n    estimator = Estimator()\n    for op in ops:\n        job = estimator.run(\n            circuits=[chsh_circuits_no_meas] * len(individual_phases),\n            observables=[op] * len(individual_phases),\n            parameter_values=individual_phases,\n        )\n        est_result = job.result()\n        chsh_est.append(est_result)\n\n\n# &lt;CHSH1&gt; = &lt;AB&gt; - &lt;Ab&gt; + &lt;aB&gt; + &lt;ab&gt;\nchsh1_est = chsh_est[0].values - chsh_est[1].values + chsh_est[2].values + chsh_est[3].values\n\n# &lt;CHSH2&gt; = &lt;AB&gt; + &lt;Ab&gt; - &lt;aB&gt; + &lt;ab&gt;\nchsh2_est = chsh_est[0].values + chsh_est[1].values - chsh_est[2].values + chsh_est[3].values\n\n\nchsh1_est\n\narray([ 2.    ,  1.2535,  0.4515, -0.437 , -1.2705, -2.0035, -2.504 ,\n       -2.8055, -2.79  , -2.5305, -1.9595, -1.3045, -0.456 ,  0.45  ,\n        1.2835,  2.0445,  2.4955,  2.8115,  2.7665,  2.5245,  2.046 ])\n\n\n\nchsh2_est\n\narray([ 2.    ,  2.5435,  2.8155,  2.806 ,  2.5455,  1.9965,  1.303 ,\n        0.4495, -0.458 , -1.2915, -2.0405, -2.4915, -2.753 , -2.801 ,\n       -2.5375, -1.9555, -1.2975, -0.4335,  0.4305,  1.2725,  1.954 ])\n\n\n\nfig, ax = plt.subplots(figsize=(10, 6))\n# results from hardware\nax.plot(phases / np.pi, chsh1_est, \"o-\", label=\"CHSH1\", zorder=3)\nax.plot(phases / np.pi, chsh2_est, \"o-\", label=\"CHSH2\", zorder=3)\n# classical bound +-2\nax.axhline(y=2, color=\"0.9\", linestyle=\"--\", )\nax.axhline(y=-2, color=\"0.9\", linestyle=\"--\")\n# quantum bound, +-2‚àö2\nax.axhline(y=np.sqrt(2) * 2, color=\"0.9\", linestyle=\"-.\")\nax.axhline(y=-np.sqrt(2) * 2, color=\"0.9\", linestyle=\"-.\")\nax.fill_between(phases / np.pi, 2, 2 * np.sqrt(2), color=\"0.6\", alpha=0.7)\nax.fill_between(phases / np.pi, -2, -2 * np.sqrt(2), color=\"0.6\", alpha=0.7)\n# set x tick labels to the unit of pi\nax.xaxis.set_major_formatter(tck.FormatStrFormatter(\"%g $\\pi$\"))\nax.xaxis.set_major_locator(tck.MultipleLocator(base=0.5))\n# set title, labels, and legend\nplt.title(\"Violation of CHSH Inequality\")\nplt.xlabel(\"Theta\")\nplt.ylabel(\"CHSH witness\")\nplt.legend();\n\n\n\n\n\n\n\nimgCSH.png"
  },
  {
    "objectID": "posts/VQE/index.html",
    "href": "posts/VQE/index.html",
    "title": "Variational Quantum Eigensolver from scratch",
    "section": "",
    "text": "Understanding and developing intuition of VQE and coding it from the basics."
  },
  {
    "objectID": "posts/PKb/18_Phase Kickback.html",
    "href": "posts/PKb/18_Phase Kickback.html",
    "title": "Phase Kickback",
    "section": "",
    "text": "Phase kickback is an interesting and useful phenomenon that is used in the design principles of many quantum algorithms.\nWe apply a Controlled-NOT operator, but the controller qubit will be affected!\nCNOT is an operator defined on two qubits:\n\\[ CNOT = \\begin{pmatrix}1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0\\end{pmatrix}\\]\nIts effect is very simple: if the state of the first qubit is one, then the state of the second qubit is flipped.\nIf the state of the first qubit is zero, then the state of the second qubit remains the same.\nCNOT refers to as Controlled-NOT: NOT operator is applied in a controlled way."
  },
  {
    "objectID": "posts/PKb/18_Phase Kickback.html#changed-to-11-after-the-measurement",
    "href": "posts/PKb/18_Phase Kickback.html#changed-to-11-after-the-measurement",
    "title": "Phase Kickback",
    "section": "10 changed to 11 after the measurement",
    "text": "10 changed to 11 after the measurement\nThe CNOT-gate does not have any directly measurable implications. However, the control qubit switches its phase. It takes on the phase of the target qubit.\nFor the phase of the target qubit is kicked up to the control qubit i.e.¬†control qubit takes up the phase of the target qubit, we call this phenomenon phase kickback."
  },
  {
    "objectID": "posts/Grover/Grover's.html",
    "href": "posts/Grover/Grover's.html",
    "title": "Grover‚Äôs Search Implementation",
    "section": "",
    "text": "Grover‚Äôs Search using amplitude amplification and an oracle that finds a marked element.\n\nGrover‚Äôs Search Implementation\nWe are given \\(N=2^n\\) elements, and one element is marked. The task is to find this marked element.\nWe are going to use \\(n\\) qubits. At the beginning we apply Hadamard to each qubit, so we put our quantum state into superposition. The amplitude of each basis state is set to $ $. After that we iterate the following algorithm for several times:\n\n\nMake a query: apply a query oracle operator to qubits - it flips the sign of the amplitude of the state that corresponds to the marked element.\n\n\nInversion: apply a diffusion matrix - the amplitude of each state is reflected over the mean of all amplitudes.\n\n\n\nQuery operation\n\n\nOracle\n\nSuppose that there exists a function \\(f:\\{0,1\\}^n \\rightarrow \\{0,1\\}\\) with the following properties:\n\\[\\begin{align*}\nf(x)&=1 &\\mbox{ if $x$ is marked}\\\\\nf(x)&=0 &\\mbox{ otherwise}\n\\end{align*}\\]\nGrover‚Äôs algorithm does not actually search a list of elements, but given function \\(f\\) with the above properties, it finds the element \\(x\\) such that \\(f(x)=1\\).\nConsider the following function f:{0,1}^2 {0,1}. Which element is marked? How many queries should you make to \\(f\\) to find out the marked element in the worst case?\nf:\n\\[\\begin{array}{c|c} \\mathbf{In} & \\mathbf{Out} \\\\ \\hline  |00&gt; & 0 \\\\ |01&gt; & 0 \\\\ |10&gt; & 0 \\\\ |11&gt; & 1      \\end{array}\\]\nf is often called as the oracle or blackbox.\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer\n\nqreg = QuantumRegister(3)\n\nmycircuit = QuantumCircuit(qreg)\n\n\n#set ancilla\nmycircuit.x(qreg[2])\nmycircuit.h(qreg[2])\n\nmycircuit.ccx(qreg[0],qreg[1],qreg[2])\n    \n#set ancilla back\nmycircuit.h(qreg[2])\nmycircuit.x(qreg[2]) \n\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x7fc5e65d7af0&gt;\n\n\n\njob = execute(mycircuit,Aer.get_backend('unitary_simulator'))\nu=job.result().get_unitary(mycircuit,decimals=3).data\n\n#We are interested in the top-left 4x4 part\nfor i in range(4):\n    s=\"\"\n    for j in range(4):\n        val = str(u[i][j].real)\n        while(len(val)&lt;5): val  = \" \"+val\n        s = s + val\n    print(s)\n    \n\nmycircuit.draw(output='mpl')\n\n  1.0  0.0  0.0  0.0\n  0.0  1.0  0.0  0.0\n  0.0  0.0  1.0  0.0\n  0.0  0.0  0.0 -1.0\n\n\n\n\n\n\n\ndef inversion(circuit,quantum_reg):\n    \n    \n    #step 1\n    circuit.h(quantum_reg[1])\n    circuit.h(quantum_reg[0])\n    \n    #step 2\n    circuit.x(quantum_reg[1])\n    circuit.x(quantum_reg[0])\n\n    #step 3\n    circuit.ccx(quantum_reg[1],quantum_reg[0],quantum_reg[2])\n\n    #step 4\n    circuit.x(quantum_reg[1])\n    circuit.x(quantum_reg[0])\n    \n    #step 5\n    circuit.x(quantum_reg[2])\n    \n    #step 6\n    circuit.h(quantum_reg[1])\n    circuit.h(quantum_reg[0])\n\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer\n\nqreg = QuantumRegister(3)\ncreg = ClassicalRegister(2)\n\nmycircuit = QuantumCircuit(qreg,creg)\n\n#Grover\n\n\n#initial step - equal superposition\n#\n#your code here\n#\n\nfor i in range(2):\n    mycircuit.h(qreg[i])\n\n#set ancilla \n#\n#your code here\n#\n\nmycircuit.x(qreg[2])\nmycircuit.h(qreg[2])\n\n\n\n#change the number of iterations\niterations=1\n\n#Grover's iterations.\n#\n#Query operator\n#\n#Inversion operator\n#\nmycircuit.ccx(qreg[0],qreg[1],qreg[2])\n\ninversion(mycircuit, qreg)\n   \n#set ancilla\n#\n#your code here\n#\n\nmycircuit.h(qreg[2])\nmycircuit.x(qreg[2])\n\nmycircuit.measure(qreg[0],creg[0])\nmycircuit.measure(qreg[1],creg[1])\n\njob = execute(mycircuit,Aer.get_backend('qasm_simulator'),shots=10000)\ncounts = job.result().get_counts(mycircuit)\n\n# print the outcome\nfor outcome in counts:\n    print(outcome,\"is observed\",counts[outcome],\"times\")\n\nmycircuit.draw(output='mpl')\n\n11 is observed 10000 times"
  },
  {
    "objectID": "posts/pi/Estimating_Pi.html",
    "href": "posts/pi/Estimating_Pi.html",
    "title": "Estimating Pi using Quantum Computer",
    "section": "",
    "text": "Approximating pi has roots in QFT and QPE, a good application for both the concepts.\nResources used : https://www.youtube.com/watch?v=5kcoaanYyZw&t=622s; and https://www.youtube.com/watch?v=YpcT8u2a2jcm"
  },
  {
    "objectID": "posts/pi/Estimating_Pi.html#build-the-first-part-of-qpe-before-the-inverse-qft-it-involves-a-series-of-hadamard-and-unitary",
    "href": "posts/pi/Estimating_Pi.html#build-the-first-part-of-qpe-before-the-inverse-qft-it-involves-a-series-of-hadamard-and-unitary",
    "title": "Estimating Pi using Quantum Computer",
    "section": "Build the first part of QPE before the Inverse QFT, it involves a series of Hadamard and Unitary",
    "text": "Build the first part of QPE before the Inverse QFT, it involves a series of Hadamard and Unitary\n\nn = 4\ncircuit = QuantumCircuit(n + 1, n)\n\n\ndef qpe_initial(circuit, n):\n    circuit.h(range(n))\n    circuit.x(n)\n\n    for x in reversed(range(n)):\n        for a in range(2**(n-1-x)):\n            circuit.cp(1, n-1-x, n)\n    return circuit\n\n\ntest = qpe_initial(circuit, n)\ntest.draw('mpl')"
  },
  {
    "objectID": "posts/pi/Estimating_Pi.html#inverse-qft",
    "href": "posts/pi/Estimating_Pi.html#inverse-qft",
    "title": "Estimating Pi using Quantum Computer",
    "section": "Inverse QFT",
    "text": "Inverse QFT\n\ndef iqft(circuit, n):\n    for q in range(int(n/2)):\n        circuit.swap(q, n-q-1)\n    for j in range(0,n):\n        for m in range(j):\n            circuit.cp(-math.pi/float(2**(j-m)), m, j)\n        circuit.h(j)\n    return circuit\n\n\ntest = iqft(test, n)\ntest.draw('mpl')\n\n\n\n\n\ntest.measure(range(n), range(n))\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x7fbdab490e20&gt;\n\n\n\ntest.draw('mpl')\n\n\n\n\n\nsimulator = Aer.get_backend('qasm_simulator')\ncounts = execute(test, backend=simulator, shots=10000).result().get_counts()\n\n\ncounts\n\n{'1011': 46,\n '1001': 44,\n '0101': 166,\n '1110': 71,\n '0000': 175,\n '1111': 93,\n '1101': 50,\n '1010': 45,\n '1000': 39,\n '0100': 478,\n '1100': 58,\n '0111': 63,\n '0011': 4926,\n '0001': 453,\n '0110': 102,\n '0010': 3191}\n\n\n\nmax_counts_result = max(counts, key=counts.get)\nmax_counts_result\n\n'0011'\n\n\n\nmax_counts_result = int(max_counts_result, 2)\nmax_counts_result\n\n3\n\n\n\ntheta = max_counts_result/2**n\nval = 1./(2*theta)\nval\n\n2.6666666666666665"
  },
  {
    "objectID": "posts/pi/Estimating_Pi.html#this-seems-ok-putting-it-all-together",
    "href": "posts/pi/Estimating_Pi.html#this-seems-ok-putting-it-all-together",
    "title": "Estimating Pi using Quantum Computer",
    "section": "This seems ok, putting it all together",
    "text": "This seems ok, putting it all together\n\ndef estimate_pi(n):\n    print(\"estimating for qubit\", n)\n    circuit = QuantumCircuit(n + 1, n)\n    circuit = qpe_initial(circuit, n)\n    circuit = iqft(circuit, n)\n    circuit.measure(range(n), range(n))\n    counts = execute(circuit, backend=simulator, shots=10000).result().get_counts()\n    max_counts_result = max(counts, key=counts.get)\n    max_counts_result = int(max_counts_result, 2)\n    theta = max_counts_result/2**n\n    val = 1/(2*theta)\n    return val"
  },
  {
    "objectID": "posts/pi/Estimating_Pi.html#kernel-dies-on-14th-iteration-so-restrict-number-of-qubits-to-14",
    "href": "posts/pi/Estimating_Pi.html#kernel-dies-on-14th-iteration-so-restrict-number-of-qubits-to-14",
    "title": "Estimating Pi using Quantum Computer",
    "section": "Kernel dies on 14th iteration, so restrict number of qubits to 14",
    "text": "Kernel dies on 14th iteration, so restrict number of qubits to 14\n\npi_values = []\nrange_n = 14\nfor i in range(2, range_n):\n    pi_values.append(estimate_pi(i))\n\nestimating for qubit 2\nestimating for qubit 3\nestimating for qubit 4\nestimating for qubit 5\nestimating for qubit 6\nestimating for qubit 7\nestimating for qubit 8\nestimating for qubit 9\nestimating for qubit 10\nestimating for qubit 11\nestimating for qubit 12\nestimating for qubit 13\n\n\n\npi_values\n\n[2.0,\n 4.0,\n 2.6666666666666665,\n 3.2,\n 3.2,\n 3.2,\n 3.1219512195121952,\n 3.1604938271604937,\n 3.1411042944785277,\n 3.1411042944785277,\n 3.1411042944785277,\n 3.1411042944785277]"
  },
  {
    "objectID": "posts/pi/Estimating_Pi.html#plot",
    "href": "posts/pi/Estimating_Pi.html#plot",
    "title": "Estimating Pi using Quantum Computer",
    "section": "Plot",
    "text": "Plot\n\nimport matplotlib.pyplot as plt\n\n\nplt.plot(list(range(2,14)), pi_values)\nplt.plot(list(range(2,14)), [math.pi]*len(list(range(2,14))), '--y')\nplt.xlabel('Number of qubits', fontdict={'size':10})\nplt.ylabel('$\\pi$ and estimate of $\\pi$', fontdict={'size':10})\n\nText(0, 0.5, '$\\\\pi$ and estimate of $\\\\pi$')"
  },
  {
    "objectID": "posts/Worm/15_Schrodinger's worm.html",
    "href": "posts/Worm/15_Schrodinger's worm.html",
    "title": "Schr√∂dinger‚Äôs Worm",
    "section": "",
    "text": "Schr√∂dinger had many pets it seems. This worm exhibits quantum behavior that‚Äôs fun to examine."
  },
  {
    "objectID": "posts/Worm/15_Schrodinger's worm.html#the-worm-is-next-to-a-hungry-bird-such-that-the-worm-is-either-alive-or-chomped-to-pieces-as-figure-above",
    "href": "posts/Worm/15_Schrodinger's worm.html#the-worm-is-next-to-a-hungry-bird-such-that-the-worm-is-either-alive-or-chomped-to-pieces-as-figure-above",
    "title": "Schr√∂dinger‚Äôs Worm",
    "section": "The worm is next to a hungry bird, such that the worm is either alive or chomped to pieces as figure above",
    "text": "The worm is next to a hungry bird, such that the worm is either alive or chomped to pieces as figure above"
  },
  {
    "objectID": "posts/Entanglement/lab2.html",
    "href": "posts/Entanglement/lab2.html",
    "title": "Entanglement and CHSH Inequality",
    "section": "",
    "text": "How quantum mechnaics can‚Äôt be described by the hidden variable theory."
  },
  {
    "objectID": "posts/Entanglement/lab2.html#getting-started",
    "href": "posts/Entanglement/lab2.html#getting-started",
    "title": "Entanglement and CHSH Inequality",
    "section": "Getting Started",
    "text": "Getting Started\nStart by importing some libraries we need, including the Sampler and Estimator primitives from Qiskit. While the primitives from qiskit.providers use a local statevector simulator by default, the syntax within this lab is easily generalizable to running experiments on real systems.\nTo run on real hearware requires a Qiskit Runtime service instance. If you haven‚Äôt done so already, follow the instructions in the Qiskit Getting started guide to set one up. TODO: include video links and such. After setup, import the Sampler and Estimator primitives from qiskit_ibm_runtime instead. Additionally we will need QiskitRuntimeService and Session, which form the interface between Qiskit and Qiskit IBM Runtime. Then the below exercises can be run on real systems by instantiating the primitives in this way (as opposed to from qiskit.primitives):\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler, Estimator\n\nservice = QiskitRuntimeService()\nbackend = service.get_backend('...')\nsession = Session(service=service, backend=backend)\nsampler = Sampler(session=session)\nestimator = Estimator(session=session)\nwhere additional options can be specified in the Sampler and Estimator with the Options class. See this how-to for using Primitives with Runtime Sessions.\n\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.primitives import Estimator, Sampler\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.visualization import plot_histogram\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('dark_background') # optional"
  },
  {
    "objectID": "posts/Entanglement/lab2.html#chsh-inequality-violation",
    "href": "posts/Entanglement/lab2.html#chsh-inequality-violation",
    "title": "Entanglement and CHSH Inequality",
    "section": "CHSH Inequality Violation",
    "text": "CHSH Inequality Violation\n\nWarm Up\nCreate circuits that put the qubit in the excited \\(|1\\rangle\\) and superposition \\(|+\\rangle\\) states, respectivly, and measure them in different bases. This is done first with the Sampler primitive (which is most similar to the backend.run() used in the previous lab), and then with the Estimator primitive to show how measurement is abstracted in that we do not need to worry about rotating the qubit into the appropriate measurement basis. The primitives will be executed withing the Session context which allows efficiency to optimize workloads.\n\n# create excited |1&gt; state\nqc_1 = QuantumCircuit(1)\nqc_1.x(0)\nqc_1.draw('mpl')\n\n\n\n\n\n# create superposition |+&gt; state\nqc_plus = QuantumCircuit(1)\nqc_plus.h(0)\nqc_plus.draw('mpl')\n\n\n\n\n\n\nSampler Primitive\nFirst use the Sampler to measure qubits in the \\(Z\\)-basis (the physical basis in which qubits are measured). The Sampler will count the number of outcomes of the \\(|0\\rangle\\) state and \\(|1\\rangle\\) state, normalized by the number of shots (experiments performed). The Sampler also offers the ability to easily perform error mitigation (which is covered in Lab 5), which modifies this calculation, and hence the outcomes are refered to as quasi-probabilities.\nMeasurments must be present in the circuit when using the Sampler primitive. Then the Session context is opened, the Sampler is instantiated, and sampler.run() is used to send the circuits to the backend, similar to the backend.run() syntax you may already be familiar with.\n\nqc_1.measure_all()\nqc_plus.measure_all()\n\nsampler = Sampler()\njob_1 = sampler.run(qc_1)\njob_plus = sampler.run(qc_plus)\n\n\njob_1.result().quasi_dists\n\n[{1: 1.0}]\n\n\n\njob_plus.result().quasi_dists\n\n[{0: 0.4999999999999999, 1: 0.4999999999999999}]\n\n\n\nlegend = [\"Excited State\", \"Plus State\"] # TODO: Excited State does not appear\nplot_histogram([job_1.result().quasi_dists[0], job_plus.result().quasi_dists[0]], legend=legend)\n\n\n\n\nThe result for the excited state is always \\(|1\\rangle\\) wheres it is roughly half \\(|0\\rangle\\) and half \\(|1\\rangle\\) for the plus superposition state. This is because the \\(|0\\rangle\\) and \\(|1\\rangle\\) states are eigenstates of the \\(Z\\) operator (with \\(+1\\) and \\(-1\\) eigenvalues, respectively).\nLet‚Äôs switch and measure in the \\(X\\) basis. Using the Sampler we must rotate the qubit from the \\(X\\)-basis to the \\(Z\\)-basis for measurement (because that is the only basis we can actually perform measurement in).\n\nqc_1.remove_final_measurements()\nqc_plus.remove_final_measurements()\n\n# rotate into the X-basis\nqc_1.h(0)\nqc_plus.h(0)\n\nqc_1.measure_all()\nqc_plus.measure_all()\n\n\nsampler = Sampler()\njob_1 = sampler.run(qc_1)\njob_plus = sampler.run(qc_plus)\n\n\nplot_histogram([job_1.result().quasi_dists[0], job_plus.result().quasi_dists[0]], legend=legend)\n\n\n\n\nNow we see the opposite: the plus superposition always give the 1 result, hence an eigenstate of the \\(X\\) operator, whereas the excited \\(|1\\rangle\\) yields a roughtly fifty-fifty split. The \\(|+\\rangle\\) and \\(|-\\rangle\\) states are eigenstates of the \\(X\\) operator, with eigenvalues \\(+1\\) and \\(-1\\), respectively. This is good to remember when considering how the Estimator works in the next subsection.\n\n\nEstimator Primitive\nThe Qiskit Runtime Primitives allow us to abstract measurement into the Estimator primitive, where it is specified as an observable. In particular, we can construct the same circuits, the excited \\(|1\\rangle\\) and superposition \\(|+\\rangle\\) as before. However, in the case of the Estimator, we do not add measurements to the circuit. Instead, specify a list of observables which take the form of Pauli strings. In our case for a measurement of a single qubit, we specify 'Z' for the \\(Z\\)-basis and 'X' for the \\(X\\)-basis.\n\nqc2_1 = QuantumCircuit(1)\nqc2_1.x(0)\n\nqc2_plus = QuantumCircuit(1)\nqc2_plus.h(0)\n\nobsvs = list(SparsePauliOp(['Z', 'X']))\n\n\nestimator = Estimator()\njob2_1 = estimator.run([qc2_1]*len(obsvs), observables=obsvs)\njob2_plus = estimator.run([qc2_plus]*len(obsvs), observables=obsvs)\n\n\njob2_1.result()\n\nEstimatorResult(values=array([-1.,  0.]), metadata=[{}, {}])\n\n\n\n# TODO: make this into module that outputs a nice table\nprint(f'    |   &lt;Z&gt;   |   &lt;X&gt; ')\nprint(f'----|------------------')\nprint(f'|1&gt; | {job2_1.result().values[0]}    | {job2_1.result().values[1]}')\nprint(f'|+&gt; | {job2_plus.result().values[0]} | {job2_plus.result().values[1]}')\n\n    |   &lt;Z&gt;   |   &lt;X&gt; \n----|------------------\n|1&gt; | -1.0    | 0.0\n|+&gt; | 0.0 | 0.9999999999999998\n\n\nJust as before, we see the \\(|1\\rangle\\) state expectation in the \\(Z\\)-basis is \\(-1\\) (corresponding to its eigenvalue) and around zero in the \\(X\\)-basis (average over \\(+1\\) and \\(-1\\) eigenvalues), and vice-versa for the \\(|+\\rangle\\) state (although its eigenvalue of the \\(X\\) operators is \\(+1\\))."
  },
  {
    "objectID": "posts/Entanglement/lab2.html#chsh-inequality",
    "href": "posts/Entanglement/lab2.html#chsh-inequality",
    "title": "Entanglement and CHSH Inequality",
    "section": "CHSH Inequality",
    "text": "CHSH Inequality\nImagine Alice and Bob are given each one part of a bipartite entangled system. Each of them then performs two measurements on their part in two different bases. Let‚Äôs call Alice‚Äôs bases A and a and Bob‚Äôs B and b. What is the expectation value of the quantity\n\\[\n\\langle CHSH \\rangle = \\langle AB \\rangle - \\langle Ab \\rangle + \\langle aB \\rangle + \\langle ab \\rangle ?\n\\]\nNow, Alice and Bob have one qubit each, so any measurement they perform on their system (qubit) can only yield one of two possible outcomes: +1 or -1. Note that whereas we typically refer to the two qubit states as \\(|0\\rangle\\) and \\(|1\\rangle\\), these are eigenstates, and a projective measurement will yield their eigenvalues, +1 and -1, respectively.\nTherefore, if any measurement of A, a, B, and b can only yield \\(\\pm 1\\), the quantities \\((B-b)\\) and \\((B+b)\\) can only be 0 or \\(\\pm 2\\). And thus, the quantity \\(A(B-b) + a(B+b)\\) can only be either +2 or -2, which means that there should be a bound for the expectation value of the quantity we have called\n\\[\n|\\langle CHSH \\rangle| = |\\langle AB \\rangle - \\langle Ab \\rangle + \\langle aB \\rangle + \\langle ab \\rangle| \\le 2.\n\\]\nNow, the above discussion is oversimplified, because we could consider that the outcome on any set of measurements from Alice and Bob could depend on a set of local hidden variables, but it can be shown with some math that, even when that is the case, the expectation value of the quantity \\(CHSH\\) should be bounded by 2 if local realism held.\nBut what happens when we do these experiments with an entangled system? Let‚Äôs try it!\nThe first step is to build the observable \\[\nCHSH = A(B-b) + a(B+b) = AB - Ab + aB +ab\n\\] where \\(A, a\\) are each one of \\(\\{IX, IZ\\}\\) for qubit 0 and \\(B, b\\) are each one of \\(\\{XI, ZI\\}\\) for qubit 1 (corresponding to little-endian notation). Paulis on different qubits can be composed by specifying order with a Pauli string, for example instantiating a SparsePauliOp with the 'ZX' argument implies a measurement of \\(\\langle X \\rangle\\) on q0 and \\(\\langle Z \\rangle\\) on q1 . This tensor product (combining operations on different qubits) can be explicitly stated using the .tensor() method. Additionally, combining operations on the same qubit(s) uses the compositional product with the .compose() method. For example, all these statements create the same Pauli operator:\nfrom qiskit.quantum_info import SparsePauliOp\n\nZX = SparsePauliOp('ZX')\nZX = SparsePauliOp(['ZX'], coeffs=[1.]) # extendable to a sum of Paulis\nZX = SparsePauliOp('Z').tensor(SparsePauliOp('X')) # extendable to a tensor product of Paulis\nZX = SparsePauliOp('XZ').compose(SparsePauliOp('YY')) # extendable to a compositional product of Paulis\nEx 1 - create an operator for CHSH witness\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Session\n\n\nZZ = SparsePauliOp.from_list([(\"ZZ\", 1)])\nZX = SparsePauliOp.from_list([(\"ZX\", 1)])\nXZ = SparsePauliOp.from_list([(\"XZ\", 1)])\nXX = SparsePauliOp.from_list([(\"XX\", 1)])\n\n\nZZ +ZX\n\nSparsePauliOp(['ZZ', 'ZX'],\n              coeffs=[1.+0.j, 1.+0.j])\n\n\n\nobsv = ZZ - ZX + XZ + XX # create operator for chsh witness\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab2_ex1\n\ngrade_lab2_ex1(obsv)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nCreate Entangled Qubit Pair\nNext we want to test the \\(CHSH\\) observable on an entangled pair, for example the maximally-entangled Bell state \\[\n|\\Phi\\rangle = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle \\right)\n\\] which is created with a Hadamard gate followed by a CNOT with the target on the same qubit as the Hadamard. Due to the simplifaction of measuring in just the \\(X\\)- and \\(Z\\)-bases as discussed above, we will rotate the Bell state around the Bloch sphere which is equivalant to changing the measurement basis as demonstrated in the Warmup section. This can be done by applying an \\(R_y(\\theta)\\) gate where \\(\\theta\\) is a Parameter to be specified at the Estimator API call. This produces the state \\[\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}} \\left(\\cos(\\theta/2) |00\\rangle + \\sin(\\theta/2)|11\\rangle \\right)\n\\]\n\nfrom qiskit.circuit import Parameter\n\ntheta = Parameter('Œ∏')\n\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.ry(theta, 0)\n\nqc.draw('mpl')\n\n\n\n\nNext we need to specify a Sequence of Parameters that show a clear violation of the CHSH Inequality, namely \\[\n|\\langle CHSH \\rangle| &gt; 2.\n\\] Let‚Äôs make sure we have at least three points in violation.\nEx 2 - Create a Parameterization (i.e., list, array) of the angle in the above circuit (in radians)\nHint: Note the type for the parameter_values argument is Sequence[Sequence[float]].\n\nnumber_of_phases = 25\nphases = np.linspace(0, 2 * np.pi, number_of_phases)\nangles = []\nfor p in phases:\n    angles.append([p])   \nangles\n\n[[0.0],\n [0.2617993877991494],\n [0.5235987755982988],\n [0.7853981633974483],\n [1.0471975511965976],\n [1.308996938995747],\n [1.5707963267948966],\n [1.832595714594046],\n [2.0943951023931953],\n [2.356194490192345],\n [2.617993877991494],\n [2.8797932657906435],\n [3.141592653589793],\n [3.4033920413889422],\n [3.665191429188092],\n [3.926990816987241],\n [4.1887902047863905],\n [4.45058959258554],\n [4.71238898038469],\n [4.974188368183839],\n [5.235987755982988],\n [5.497787143782138],\n [5.759586531581287],\n [6.021385919380436],\n [6.283185307179586]]\n\n\nTest your angles and observable by running with the Estimator before submitting to the grader.\n\nfrom qiskit.primitives import Estimator, Sampler\n\n\nestimator = Estimator()\njob = estimator.run([qc]*len(angles), observables=[obsv]*len(angles), parameter_values=angles)\nexps = job.result().values\n\nplt.plot(angles, exps, marker='x', ls='-', color='green')\nplt.plot(angles, [2]*len(angles), ls='--', color='red', label='Classical Bound')\nplt.plot(angles, [-2]*len(angles), ls='--', color='red')\nplt.xlabel('angle (rad)')\nplt.ylabel('CHSH Witness')\nplt.legend(loc=4)\n\n&lt;matplotlib.legend.Legend at 0x7fcb80419060&gt;\n\n\n\n\n\nDid you see at least 3 points outside the red dashed lines? If so, you are ready to send to the grader!\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab2_ex2\n\ngrade_lab2_ex2(obsv, angles)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nimport qiskit.tools.jupyter\n%qiskit_version_table\n\nVersion Information\n\n\n\nQiskit Software\nVersion\n\n\nqiskit-terra\n0.24.1\n\n\nqiskit-aer\n0.12.1\n\n\nqiskit-ibmq-provider\n0.20.2\n\n\nqiskit\n0.43.2\n\n\nqiskit-nature\n0.6.2\n\n\nqiskit-finance\n0.3.4\n\n\nqiskit-optimization\n0.5.0\n\n\nqiskit-machine-learning\n0.6.1\n\n\nSystem information\n\n\n\nPython version\n3.10.8\n\n\nPython compiler\nGCC 10.4.0\n\n\nPython build\nmain, Nov 22 2022 08:26:04\n\n\nOS\nLinux\n\n\nCPUs\n8\n\n\nMemory (Gb)\n31.211322784423828\n\n\nFri Jul 21 19:11:24 2023 UTC"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "|quantum learnings>",
    "section": "",
    "text": "Phase Kickback\n\n\n\n\n\n\n\ncomputing principles\n\n\n\n\n\n\n\n\n\n\n\nAug 4, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\n  \n\n\n\n\nVariational Quantum Eigensolver from scratch\n\n\n\n\n\n\n\nbasic implementation\n\n\n\n\n\n\n\n\n\n\n\nAug 1, 2023\n\n\n\n\n\n\n  \n\n\n\n\nExplanation of Heisenberg‚Äôs Uncertainty Principle\n\n\n\n\n\n\n\nquantum theory\n\n\n\n\n\n\n\n\n\n\n\nJul 30, 2023\n\n\n\n\n\n\n  \n\n\n\n\nEstimating Pi using Quantum Computer\n\n\n\n\n\n\n\napplications\n\n\n\n\n\n\n\n\n\n\n\nJul 26, 2023\n\n\n\n\n\n\n  \n\n\n\n\nTossing Quantum Coins and Winning\n\n\n\n\n\n\n\nfun\n\n\ncircuits\n\n\n\n\n\n\n\n\n\n\n\nJul 22, 2023\n\n\n\n\n\n\n  \n\n\n\n\nDirac Notation and Quantum Circuits\n\n\n\n\n\n\n\nquantum theory\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nJul 17, 2023\n\n\n\n\n\n\n  \n\n\n\n\nGrover‚Äôs Search Implementation\n\n\n\n\n\n\n\nqiskit\n\n\nalgorithms\n\n\n\n\n\n\n\n\n\n\n\nJul 8, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\n  \n\n\n\n\nSchr√∂dinger‚Äôs Worm\n\n\n\n\n\n\n\nfun\n\n\n\n\n\n\n\n\n\n\n\nJun 30, 2023\n\n\n\n\n\n\n  \n\n\n\n\nHeisenberg‚Äôs Uncertainty Principle\n\n\n\n\n\n\n\nquantum theory\n\n\n\n\n\n\n\n\n\n\n\nJun 12, 2023\n\n\n\n\n\n\n  \n\n\n\n\nQuantum Teleportation\n\n\n\n\n\n\n\nquantum theory\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nJun 6, 2023\n\n\n\n\n\n\n  \n\n\n\n\nEntanglement and CHSH Inequality\n\n\n\n\n\n\n\nquantum theory\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nMay 28, 2023\n\n\n\n\n\n\n  \n\n\n\n\nNobel Prize for Physics in 2022\n\n\n\n\n\n\n\nquantum theory\n\n\n\n\n\n\n\n\n\n\n\nMay 25, 2023\n\n\n\n\n\n\n  \n\n\n\n\nRandom Number Generator\n\n\n\n\n\n\n\nfun\n\n\n\n\n\n\n\n\n\n\n\nMay 20, 2023\n\n\n\n\n\n\nNo matching items"
  }
]