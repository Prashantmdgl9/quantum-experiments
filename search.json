[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Prashant Mudgal",
    "section": "",
    "text": "In this blog, I am documenting my learning journey in quantum computing and quantum mechanics.\nI am mainly writing for myself, trying to explain/clarify concepts to myself while writing and crystallising them for future use too.\nThrough this blog, I am implementing the concept of ‚ÄúThe Best Way to Learn s to Teach‚Äù.\nIf you stumbled across this blog and you find it useful, then that‚Äôs destiny :)"
  },
  {
    "objectID": "posts/Dirac/lab1.html",
    "href": "posts/Dirac/lab1.html",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "",
    "text": "Getting started with Dirac notation and qiskit circuits"
  },
  {
    "objectID": "posts/Dirac/lab1.html#vectors-and-dirac-notation",
    "href": "posts/Dirac/lab1.html#vectors-and-dirac-notation",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Vectors and Dirac Notation",
    "text": "Vectors and Dirac Notation\nIn the lectures you learned different ways of representing quantum states, including how to use bra-ket (Dirac) notation.\nAlthough bra-ket notation cannot be represented exactly in code, we can represent their vector and matrix equivalent with python.\nE.g. we can represent \\(|0\\rangle\\) using a python list:\n\nket0 = [[1],[0]]\n\nAnd we can use one of Qiskit‚Äôs visualisation tools to make our vectors nicer to look at:\n\narray_to_latex(ket0)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can do the same with \\(\\langle0|\\):\n\nbra0 = [1,0]\narray_to_latex(bra0)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 1 - create \\(|1\\rangle\\) and \\(\\langle1|\\) with python lists\n\n\nket1 = [[0], [1]]\nbra1 = [0 , 1]\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex1 \n\ngrade_lab1_ex1([ket1, bra1])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#qiskit-statevector-class",
    "href": "posts/Dirac/lab1.html#qiskit-statevector-class",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Qiskit Statevector Class",
    "text": "Qiskit Statevector Class\nIn the lectures you learned about using state vectors to represent quantum states. You can represent quantum state vectors in code using Qiskit‚Äôs Statevector class.\nQiskit‚Äôs Statevector class can take different forms of input (e.g.¬†python list, numpy array, another state vector) to construct a state vector.\nLet‚Äôs take the bra0 object we created earlier and convert it to a Statevector object:\n\nsv_bra0 = Statevector(bra0)\n\nsv_bra0\n\nStatevector([1.+0.j, 0.+0.j],\n            dims=(2,))\n\n\nThe Statevector class has its own draw() method:\n\nsv_bra0.draw('latex')\n\n\\[ |0\\rangle\\]\n\n\nWe can create more complex statevectors with multiple qubits like this:\n\nsv_eq = Statevector([1/2, 3/4, 4/5, 6/8])\n\nsv_eq.draw('latex')\n\n\\[\\frac{1}{2} |00\\rangle+\\frac{3}{4} |01\\rangle+\\frac{4}{5} |10\\rangle+\\frac{3}{4} |11\\rangle\\]\n\n\nNote that the vector above is not a valid state vector as it is not normalised. We can check this with the is_valid() method:\n\nsv_eq.is_valid()\n\nFalse\n\n\n\nEx 2 - create your own valid statevector object using the Statevector class\n\n\nsv_valid = Statevector([1/2, 1/2, 1/2, 1/2])\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex2 \n\ngrade_lab1_ex2(sv_valid)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#qiskit-operator-class",
    "href": "posts/Dirac/lab1.html#qiskit-operator-class",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Qiskit Operator Class",
    "text": "Qiskit Operator Class\nThe Operator class is used in Qiskit to represent matrix operators acting on a quantum system. It has several methods to build composite operators using tensor products of smaller operators, and to compose operators.\nOne way we can initialise a Qiskit Operator is by using a python list, like the one we created earlier:\n\nop_bra0 = Operator(bra0)\n\nop_bra0\n\nOperator([1.+0.j, 0.+0.j],\n         input_dims=(), output_dims=(2,))\n\n\nThe Operator class comes with some handy methods for working with operators, for example we can find the tensor product of 2 operators by using the tensor() method:\n\nop_ket0 = Operator(ket0)\nop_bra0.tensor(op_ket0)\n\nOperator([[1.+0.j, 0.+0.j],\n          [0.+0.j, 0.+0.j]],\n         input_dims=(), output_dims=(2, 2))\n\n\n\nop_ket0\n\nOperator([[1.+0.j],\n          [0.+0.j]],\n         input_dims=(), output_dims=(2,))\n\n\n\nop_ket0.tensor(op_bra0)\n\nOperator([[1.+0.j, 0.+0.j],\n          [0.+0.j, 0.+0.j]],\n         input_dims=(), output_dims=(2, 2))\n\n\nWe‚Äôll use the Operator and Statevector classes more in the following exercises."
  },
  {
    "objectID": "posts/Dirac/lab1.html#inner-outer-product",
    "href": "posts/Dirac/lab1.html#inner-outer-product",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Inner & Outer Product",
    "text": "Inner & Outer Product\nIn the lectures you covered the concepts of the inner and outer product. We can explore these concepts in code using numpy methods .dot() (the inner product is a generalised form of the dot product) and .outer().\nFor example, we can find the inner product \\(\\langle0|0\\rangle\\) like this:\n\nbraket = np.dot(op_bra0,op_ket0)\narray_to_latex(braket)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nand the outer product \\(|0\\rangle\\langle0|\\) like this:\n\nketbra = np.outer(ket0,bra0)\narray_to_latex(ketbra)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nbraket = np.dot(op_bra0,op_ket0)\narray_to_latex(braket)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nNote: the numpy methods we used above work with Qiskit Operators as well as regular python lists.\n\nEx 3 - use numpy to find the result of the following inner and outer products: \\(\\langle1|0\\rangle, \\langle0|1\\rangle, \\langle1|1\\rangle, |1\\rangle\\langle0|, |0\\rangle\\langle1|\\) and $|1| $\n\n\nbra1ket0 = np.dot(bra1,ket0)# put your answer for ‚ü®1|0‚ü© here\n\nbra0ket1 = np.dot(bra0,ket1)# put your answer for ‚ü®0|1‚ü© here\n\nbra1ket1 = np.dot(bra1,ket1)# put your answer for ‚ü®1|1‚ü© here\n\nket1bra0 = np.outer(ket1,bra0)# put your answer for |1‚ü©‚ü®0| here\n\nket0bra1 = np.outer(ket0,bra1) # put your answer for |0‚ü©‚ü®1| here\n\nket1bra1 = np.outer(ket1,bra1)# put your answer for |1‚ü©‚ü®1| here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex3 \n\ngrade_lab1_ex3([bra1ket0, bra0ket1, bra1ket1, ket1bra0, ket0bra1, ket1bra1])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nnp.dot(ket1, ket1)\n\nTraceback (most recent call last):\n  Cell In[30], line 1\n    np.dot(ket1, ket1)\n  File &lt;__array_function__ internals&gt;:180 in dot\nValueError: shapes (2,1) and (2,1) not aligned: 1 (dim 1) != 2 (dim 0)\n\nUse %tb to get the full traceback.\n\n\n\n\nSearch for solution online\n\n\n\n&lt;p&gt; Ex 4 - when the inner product of 2 quantum states is equal to 0, those states are orthogonal. Which of the following states are orthogonal? &lt;/p&gt;\n&lt;p&gt;a) $\\vert 0\\rangle$ and $\\vert 1\\rangle$ &lt;/p&gt;\n&lt;p&gt;b) $\\vert 0\\rangle$ and $\\vert 0\\rangle$ &lt;/p&gt;\n&lt;p&gt;c) $\\vert 1\\rangle$ and $\\vert 1\\rangle$ &lt;/p&gt;\n\n\n# add or remove your answer from this list\nanswer = ['a']\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex4 \n\ngrade_lab1_ex4(answer)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#deterministic-operations",
    "href": "posts/Dirac/lab1.html#deterministic-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Deterministic operations",
    "text": "Deterministic operations\nAs mentioned in the lectures, there are 4 single bit deterministic operations:\nf1 = constant-0\nf2 = identity\nf3 = bit flip / not\nf4 = constant-1\n\\[\n\\begin{array}{c|c}\n  a & f_1(a)\\\\\n  \\hline\n  0 & 0\\\\\n  1 & 0\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_2(a)\\\\\n  \\hline\n  0 & 0\\\\\n  1 & 1\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_3(a)\\\\\n  \\hline\n  0 & 1\\\\\n  1 & 0\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_4(a)\\\\\n  \\hline\n  0 & 1\\\\\n  1 & 1\n\\end{array}\n\\]\nWe can create Qiskit Operators for these 4 operations, by passing their matrix representations as arguments to the Operator class.\nE.g. for constant-0 we can create the corresponding matrix m1 like so:\n\nm1 = Operator([[1,1],[0,0]])\narray_to_latex(m1)\n\n$$\n\\[\\begin{bmatrix}\n1 & 1  \\\\\n0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nand similarly for m3:\n\nm3 = Operator([[0,1],[1,0]])\narray_to_latex(m3)\n\n$$\n\\[\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can also use builtin python mutliplication operations (e.g.¬†@, .dot, or .matmul) to check the following equation: $ M|a= f|a$\ne.g.¬†$ M1|0= f1|0$ = 0\n\narray_to_latex(m1@ket0)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 5 - create Qiskit Operators for m2 and m4 (hint: check out the lectures to find the appropriate matrices)\n\n\nm2 =  Operator([[1,0],[0,1]]) # create an operator for m2 here\nm4 =  Operator([[0,0],[1,1]])# create and operator for m4 here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex5\n\ngrade_lab1_ex5([m2, m4])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#probabilistic-operations",
    "href": "posts/Dirac/lab1.html#probabilistic-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Probabilistic operations",
    "text": "Probabilistic operations\nA Controlled-NOT (or CNOT) operation is a probabilistic operation you can apply on 2 qubits.\nApplying a CNOT on a state (X,Y) involves performing a NOT operation on Y when X is 1, otherwise do nothing. X is the control bit, Y is the target bit.\nWe can implement a CNOT gate (and many other quantum gates) using a class from Qiskit‚Äôs circuit library:\n\ncnot = CXGate()\n\narray_to_latex(cnot)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0 & 0 & 0  \\\\\n0 & 0 & 0 & 1  \\\\\n0 & 0 & 1 & 0  \\\\\n0 & 1 & 0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nNote: this matrix is different from the one that appeared in the lesson because CXGate() takes the right qubit to be the control rather than the left qubit."
  },
  {
    "objectID": "posts/Dirac/lab1.html#unitary-operations",
    "href": "posts/Dirac/lab1.html#unitary-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Unitary Operations",
    "text": "Unitary Operations\nAn operator is unitary if: $ UU^{} = = U^{} U$\nWe can check if an operator is Unitary using Qiskit with the is_unitary() method:\n\nm3.is_unitary()\n\nTrue\n\n\nWith small operators like m3 we could probably figure this out easily by ourselves, but with more complex operators it becomes more convenient to use the Qiskit function:\n\nrandom = Operator(np.array([[ 0.50778085-0.44607116j, -0.1523741 +0.14128434j,  0.44607116+0.50778085j,\n  -0.14128434-0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j, -0.12151822+0.16855994j,\n  -0.38038841+0.55868196j],\n [ 0.50778085-0.44607116j, -0.1523741 +0.14128434j, -0.44607116-0.50778085j,\n   0.14128434+0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j,  0.12151822-0.16855994j,\n   0.38038841-0.55868196j]]))\n\nrandom.is_unitary()\n\nTrue\n\n\n\nEx 6 - create an operator using the Operator class that is not unitary\n\n\nnon_unitary_op = Operator(np.array([[ 0.52778085-0.49607116j, -0.1523741 +0.14128434j,  0.44607116+0.50778085j,\n  -0.14128434-0.1523741j ],\n [ 0.16855994+0.17151822j,  0.55868196+0.38038841j, -0.12151822+0.16855994j,\n  -0.38038841+0.55868196j],\n [ 0.50778085-0.44607116j, -0.1523741 +0.14128434j, -0.44607116-0.50778085j,\n   0.14128434+0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j,  0.12151822-0.16855994j,\n   0.38038841-0.55868196j]]))# create your operator here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex6\n\ngrade_lab1_ex6(non_unitary_op)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nQubit Unitary Operations - Pauli Operations\nSome of the most common unitary operations in quantum computing are the Pauli operations. Qiskit‚Äôs Pauli classes make it easy to interact with Pauli operators in code:\nE.g. Pauli X (\\(\\sigma_x\\)), the bit flip:\n\npauli_x = Pauli('X')\n\narray_to_latex(pauli_x)\n\n$$\n\\[\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nPauli Y (\\(\\sigma_y\\)):\n\npauli_y = Pauli('Y')\n\narray_to_latex(pauli_y)\n\n$$\n\\[\\begin{bmatrix}\n0 & - i  \\\\\ni & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nPauli Z (\\(\\sigma_z\\)), the phase flip:\n\npauli_z = Pauli('Z')\n\narray_to_latex(pauli_z)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n0 & -1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can use the Operator class with the Pauli class:\n\nop_x = Operator(pauli_x)\n\nop_x\n\nOperator([[0.+0.j, 1.+0.j],\n          [1.+0.j, 0.+0.j]],\n         input_dims=(2,), output_dims=(2,))\n\n\nLet‚Äôs use the Operator class and numpy to find the outcome of \\(\\sigma_x|0\\rangle\\)\n\nop_new = np.dot(op_x,ket0)\n\narray_to_latex(op_new)\n\n$$\n\\[\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nop_z = Operator(pauli_z)\n\nop_z\n\nOperator([[ 1.+0.j,  0.+0.j],\n          [ 0.+0.j, -1.+0.j]],\n         input_dims=(2,), output_dims=(2,))\n\n\n\nEx 7 - Apply the Pauli-Z operator on \\(|1\\rangle\\)\n\n\nresult = np.dot(op_z, ket1) # do your operations here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex7\n\ngrade_lab1_ex7(result)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\n\nQubit Unitary Operations - Hadamard\nThe Hadamard gate is one of the most important unitary operations in quantum computing. We can implement a Hadamard gate (and many other quantum gates) using a class from Qiskit‚Äôs circuit library:\n\nhadamard = HGate()\n\narray_to_latex(hadamard)\n\n$$\n\\[\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nYou can convert many Qiskit classes to operators to make use of functions specific to the Operator class, such as is_unitary\n\nhop = Operator(hadamard)\nhop.is_unitary()\n\nTrue"
  },
  {
    "objectID": "posts/Dirac/lab1.html#quantum-circuits",
    "href": "posts/Dirac/lab1.html#quantum-circuits",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Quantum Circuits",
    "text": "Quantum Circuits\nIn the lectures you learned how to create a Quantum Circuit using a CNOT and a Hadamard gate. This circuit creates the Bell State \\(|\\phi^+\\rangle\\). We can implement this using Qiskit‚Äôs QuantumCircuit class:\n\nbell = QuantumCircuit(2)\n\nbell.h(0) # apply an H gate to the circuit\nbell.cx(0,1) # apply a CNOT gate to the circuit\n\nbell.draw(output=\"mpl\")\n\nMatplotlib is building the font cache; this may take a moment.\n\n\n\n\n\nIf we want to check what the matrix representation is of this quantum state we can convert the circuit directly to an operator:\n\nbell_op = Operator(bell)\n\narray_to_latex(bell_op)\n\n$$\n\\[\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2} & 0 & 0  \\\\\n0 & 0 & \\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n0 & 0 & \\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2} & 0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 8 - the GHZ state is similar to the Bell State but applied to 3 qubits. Create a quantum circuit outputting the GHZ state\n\n\nghz = QuantumCircuit(3)\n\n##############################\n# add gates to your circuit here\nghz.h(0)\nghz.cx(0, 1)\nghz.cx(0, 2)\n\n\n\n##############################\n\nghz.draw(output='mpl')\n\n\n\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex8\n\ngrade_lab1_ex8(ghz)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#measuring-quantum-states",
    "href": "posts/Dirac/lab1.html#measuring-quantum-states",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Measuring Quantum states",
    "text": "Measuring Quantum states\nAs explained in the lectures you can find the probability of measurement outcomes by taking the absolute value squared of the entries of a quantum state vector.\nFor example, when measuring the + state:\n$ |+= |0+ |1$\nThe probability of measuring 0 or 1 is given by the following:\n$ Pr(0) = ||^2 = $\n$ Pr(1) = ||^2 = $\nLet‚Äôs create a \\(|+\\rangle\\) using the Statevector class:\n\nplus_state = Statevector.from_label(\"+\")\n\nplus_state.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |0\\rangle+\\frac{\\sqrt{2}}{2} |1\\rangle\\]\n\n\n\nplus_state\n\nStatevector([0.70710678+0.j, 0.70710678+0.j],\n            dims=(2,))\n\n\nNow we can get the probability of measuring 0 or 1:\n\nplus_state.probabilities_dict()\n\n{'0': 0.4999999999999999, '1': 0.4999999999999999}\n\n\nThe dictionary object above shows you all the possible measurement outcomes and what the probability is of getting them. The actual act of measuring forces the state to collapse into either the 0 or 1 state:\n\n# run this cell multiple times to show collapsing into one state or the other\nres = plus_state.measure()\n\nres\n\n('0',\n Statevector([1.+0.j, 0.+0.j],\n             dims=(2,)))\n\n\nWe can implement the same \\(|+\\rangle\\) state with measurement using a quantum circuit:\n\nqc = QuantumCircuit(1,1)\nqc.h(0)\nqc.measure(0, 0)\n\nqc.draw(output=\"mpl\")\n\n\n\n\nIf we ran this circuit using a simulator we would get the same results as we did with the statevector class.\nIn the next example, let‚Äôs use the Statevector class to find the measurement outcomes for a dependent, probabilistic state. We‚Äôll find the measurement probilities for the 2-qubit Bell State \\(|\\phi^+\\rangle\\) :\n\nsv_bell = Statevector([np.sqrt(1/2), 0, 0, np.sqrt(1/2)])\n\nsv_bell.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |00\\rangle+\\frac{\\sqrt{2}}{2} |11\\rangle\\]\n\n\n\nsv_bell.probabilities_dict()\n\n{'00': 0.5000000000000001, '11': 0.5000000000000001}\n\n\n\nEx 9 - Using the Statevector class find the probabilities for the other 3 states in the Bell Basis: \\(|\\psi^+\\rangle\\), \\(|\\psi^-\\rangle\\), \\(|\\phi^-\\rangle\\). Hint: check out lesson 2 to refresh your memory on the equations of the Bell states\n\n\nsv_psi_plus = Statevector([0,np.sqrt(1/2), np.sqrt(1/2), 0])# create a statevector for |ùúì+‚ü© here\nprob_psi_plus =sv_psi_plus.probabilities_dict() # find the measurement probabilities for |ùúì+‚ü© here\n\nsv_psi_minus = Statevector([0,np.sqrt(1/2), -np.sqrt(1/2), 0])# create a statevector for |ùúì‚àí‚ü© here\nprob_psi_minus = sv_psi_minus.probabilities_dict()# find the measurement probabilities for |ùúì‚àí‚ü© here\n\nsv_phi_minus = Statevector([np.sqrt(1/2), 0, 0, -np.sqrt(1/2)])# create a statevector for |ùúô‚àí‚ü© here\nprob_phi_minus = sv_phi_minus.probabilities_dict()# find the measurement probabilities for |ùúô‚àí‚ü© here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex9\n\ngrade_lab1_ex9([prob_psi_plus, prob_psi_minus, prob_phi_minus])\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html",
    "href": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html",
    "title": "Heisenberg‚Äôs Uncertainty Principle",
    "section": "",
    "text": "What did Heisenberg really mean by the uncertainty principle?\nThe most popular form of the uncertainty principle is about position and momentum of a particule, if one is know the other is uncertain; We will examine the same but not the momentum and position but using different basis of measures.\nfrom qiskit import QuantumCircuit, assemble, Aer\nfrom math import pi, sqrt\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nsim = Aer.get_backend('aer_simulator')\n# Let's do an X-gate on a |0&gt; qubit\nqc = QuantumCircuit(1)\nqc.x(0)\nqc.draw()\n\n   ‚îå‚îÄ‚îÄ‚îÄ‚îê\nq: ‚î§ X ‚îú\n   ‚îî‚îÄ‚îÄ‚îÄ‚îò\n# Let's see the result\nqc.save_statevector()\nstate = sim.run(qc).result().get_statevector()\nplot_bloch_multivector(state)\nThe state hs been changed from 0 to 1, thats what X gate does\nqc.y(0) # Do Y-gate on qubit 0\nqc.z(0) # Do Z-gate on qubit 0\nqc.draw()\n\n   ‚îå‚îÄ‚îÄ‚îÄ‚îê statevector ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê\nq: ‚î§ X ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñë‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ Y ‚îú‚î§ Z ‚îú\n   ‚îî‚îÄ‚îÄ‚îÄ‚îò      ‚ñë      ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò\n# Create the X-measurement function:\ndef x_measurement(qc, qubit, cbit):\n    \"\"\"Measure 'qubit' in the X-basis, and store the result in 'cbit'\"\"\"\n    qc.h(qubit)\n    qc.measure(qubit, cbit)\n    return qc\n\ninitial_state = [1/sqrt(2), -1/sqrt(2)]\n# Initialize our qubit and measure it\nqc = QuantumCircuit(1,1)\nqc.initialize(initial_state, 0)\nx_measurement(qc, 0, 0)  # measure qubit 0 to classical bit 0\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ Initialize(0.70711,-0.70711) ‚îú‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                                           0\ncounts = sim.run(qc).result().get_counts()  # Do the simulation, returning the state vector\nplot_histogram(counts)  # Display the output on measurement of state vector\nWe initialized our qubit in - the state , but we can see that, after the measurement, we have collapsed our qubit to the 1 state . If you run the cell again, you will see the same result, since along the X-basis, the state - is a basis state and measuring it along X will always yield the same result.\nMeasuring in different bases allows us to see Heisenberg‚Äôs famous uncertainty principle in action. Having certainty of measuring a state in the Z-basis removes all certainty of measuring a specific state in the X-basis, and vice versa. A common misconception is that the uncertainty is due to the limits in our equipment, but here we can see the uncertainty is actually part of the nature of the qubit."
  },
  {
    "objectID": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html#heisenbergs-uncertainty-principle",
    "href": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html#heisenbergs-uncertainty-principle",
    "title": "Heisenberg‚Äôs Uncertainty Principle",
    "section": "Heisenberg‚Äôs Uncertainty principle",
    "text": "Heisenberg‚Äôs Uncertainty principle\nhttps://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-states/old-unique-properties-qubits.ipynb\n\nfrom qiskit import *\nfrom qiskit.visualization import plot_histogram\n%config InlineBackend.figure_format = 'svg' # Makes the images look nice\n\n\nmeasure_z = QuantumCircuit(1,1)\nmeasure_z.measure(0,0)\n\nmeasure_z.draw(output='mpl')\n\n\n\n\n\nmeasure_x = QuantumCircuit(1,1)\nmeasure_x.h(0)\nmeasure_x.measure(0,0)\n\nmeasure_x.draw(output='mpl')\n\n\n\n\n\nqc_0 = QuantumCircuit(1)\n\nqc_0.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_z, qc_0)\n\nqc.draw()\n\n     ‚îå‚îÄ‚îê\n  q: ‚î§M‚îú\n     ‚îî‚ï•‚îò\nc: 1/‚ïê‚ï©‚ïê\n      0 \n\n\n\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\n\n\ncounts\n\n{'0': 1024}\n\n\n\nprint('Results for z measurement:')\n\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_x, qc_0)\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n           0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\n\nqc_plus = QuantumCircuit(1)\nqc_plus.h(0)\n\nqc_plus.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_z)\n\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n           0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ H ‚îú‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two.\n\nOther rotations\n\nqc_y = QuantumCircuit(1)\nqc_y.ry( -3.14159/4,0)\n\nqc_y.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_y, measure_z)\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ Ry(-0.7854) ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                     0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\nHere we have a case that we have not seen before. The z measurement is most likely to output 0, but it is not completely certain. A similar effect is seen below for the x measurement: it is most likely, but not certain, to output 1.\n\nqc = QuantumCircuit.compose(qc_y, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îê\n  q: ‚î§ Ry(-0.7854) ‚îú‚î§ H ‚îú‚î§M‚îú\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚ï•‚îò\nc: 1/‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê\n                          0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two."
  },
  {
    "objectID": "posts/Teleport/Teleportation.html",
    "href": "posts/Teleport/Teleportation.html",
    "title": "Quantum Teleportation",
    "section": "",
    "text": "How Quantum qubits can be teleported despite No Cloning Theorem?\n\nTeleportation\nQuantum information cannot be copied due to the No Cloning Theorem, however it can be ‚Äúteleported‚Äù in the sense that a qubit can be entangled with a quantum resource, and via a protocol of measurements and classical communication of their results, the original quantum state can be reconstructed on a different qubit. This process destroys the information in the original qubit via measurement.\nIn this exercise, we will construct a particular qubit state and then transfer that state to another qubit using the teleportation protocol. Here we will be looking at specific classical and quantum registers, so we need to import those.\n\nfrom qiskit.circuit import ClassicalRegister, QuantumRegister\nfrom qiskit.circuit import Parameter\nfrom qiskit.circuit import QuantumCircuit\n\n\nCreate the circuit\nDefine an angle \\(\\theta\\) to rotate our qubit by. This will allow us to easily make comparisons for the original state and the teleported state.\n\ntheta = Parameter('Œ∏')\n\nqr = QuantumRegister(1, 'q')\nqc = QuantumCircuit(qr)\nqc.ry(theta, 0)\nqc.draw('mpl')\n\n\n\n\nAlice possesses the quantum information \\(|\\psi\\rangle\\) in the state of \\(q\\) and wishes to transfer it to Bob. The resource they share is a special entangled state called a Bell state \\[\n|\\Phi^+\\rangle = \\frac{1}{2} \\left( |00\\rangle + |11\\rangle \\right)\n\\] with the first of the pair going to Alice and the second to Bob. Hence Alice has a 2-qubit register (\\(q\\) and \\(Bell_0\\)) and Bob has a single-qubit register (\\(Bell_1\\)). We will construct the circuit by copying the original qc and adding the appropriate registers.\n\ntele_qc = qc.copy()\nbell = QuantumRegister(2, 'Bell')\nalice = ClassicalRegister(2, 'Alice')\nbob = ClassicalRegister(1, 'Bob')\ntele_qc.add_register(bell, alice, bob)\ntele_qc.draw('mpl')\n\n\n\n\nNow create the Bell pair with \\(Bell_0\\) going to Alice and \\(Bell_1\\) going to Bob. This is done by using a Hadamard gate to put \\(Bell_0\\) in the \\(|+\\rangle\\) state and then performing a CNOT with the same qubit as the control. After they receive their respective qubit, they part ways.\n\n# create Bell state with other two qubits\ntele_qc.barrier()\ntele_qc.h(1)\ntele_qc.cx(1, 2)\ntele_qc.barrier()\ntele_qc.draw('mpl')\n\n\n\n\nNext, Alice performs a CNOT controlled by \\(q\\) on \\(Bell_0\\), which maps information about the state onto it. She then applies a Hadamard gate on \\(q\\).\n\n# alice operates on her qubits\ntele_qc.cx(0, 1)\ntele_qc.h(0)\ntele_qc.barrier()\ntele_qc.draw('mpl')\n\n\n\n\nNow Alice measures her qubits and saves the results to her register.\n\n ty= ClassicalRegister(2, 'alpha')\n\n\nty[0]\n\nClbit(ClassicalRegister(2, 'alpha'), 0)\n\n\n\nty[1]\n\nClbit(ClassicalRegister(2, 'alpha'), 1)\n\n\n\ntele_qc.measure([qr[0], bell[0]], alice)\ntele_qc.draw('mpl')\n\n\n\n\nBob‚Äôs qubit now has the information \\(|\\psi\\rangle\\) from Alice‚Äôs qubit \\(q\\) encoded in \\(Bell_1\\), but he does not know what basis to measure in to extract it. Accordingly, Alice must share the information in her register over a classical communication channel (this is why teleportation does not violate special relativity, no matter how far Alice and Bob are apart). She instructs Bob to perform an X gate on his qubit if her measurement of \\(Bell_0\\) yields a 1 outcome, followed by a Z gate if her measurement of \\(q\\) yields a 1.\nThe applications of these gates can be conditioned on the measurement outcomes in two ways: - the .c_if() instruction, which applies the gate it modifies if the value of the ClassicalRegister index is equal to the value specified. Note that this works only on simulators. - the .if_test() context which operates similarly, but generalizes the syntax to allow for nested conditionals. This works on both simulators and actual hardware.\n\nbell[0]\n\nQubit(QuantumRegister(2, 'Bell'), 0)\n\n\n\nqr[0]\n\nQubit(QuantumRegister(1, 'q'), 0)\n\n\n\ndef bob_transform(qc, bob_bit, alice):\n    qc.x(bob_bit).c_if(alice[1], 1)\n    qc.z(bob_bit).c_if(alice[0], 1)\n\n\ngraded_qc = tele_qc.copy()\ngraded_qc.barrier()\nbob_transform(graded_qc, bell[1], alice)\n\n\ngraded_qc.draw('mpl')\n\n\n\n\nFinally, Bob can measure his qubit, which would yield results with the same probabilities as had Alice measured it originally.\n\ngraded_qc.barrier()\ngraded_qc.measure(bell[1], bob)\ngraded_qc.draw('mpl')\n\n\n\n\nThe statevector simulator cannot work with dynamic circuits because measurement is not a unitary operation. Therefore we import the Sampler primitive from qiskit_aer to use the AerSimulator. We choose our angle to be \\(5\\pi/7\\), which will yield a 1 result about 80% of the time and 0 result about 20% of the time. Then we run both circuits: the original one Alice had and the teleported one Bob receives.\n\nfrom qiskit_aer.primitives import Sampler\nimport numpy as np\n\nangle = 5*np.pi/7\n\nsampler = Sampler()\nqc.measure_all()\njob_static = sampler.run(qc.bind_parameters({theta: angle}))\njob_dynamic = sampler.run(graded_qc.bind_parameters({theta: angle}))\n\nprint(f\"Original Dists: {job_static.result().quasi_dists[0].binary_probabilities()}\")\nprint(f\"Teleported Dists: {job_dynamic.result().quasi_dists[0].binary_probabilities()}\")\n\nOriginal Dists: {'1': 0.806640625, '0': 0.193359375}\nTeleported Dists: {'011': 0.03515625, '111': 0.2001953125, '001': 0.05078125, '110': 0.1826171875, '100': 0.208984375, '101': 0.2431640625, '000': 0.0341796875, '010': 0.044921875}\n\n\nWait, we see different results! While measuring Alice‚Äôs original \\(q\\) yields the expected ratio of outcomes, the teleported distributions have many more values. This is because the teleported circuit includes Alice‚Äôs measurements of \\(q\\) and \\(Bell_0\\), whereas we only wish to see Bob‚Äôs measurements of \\(Bell_1\\) yield the same distribution.\nIn order to rectify this, we must take the marginal counts, meaning we combine results in which Bob measures a 0 and all the results in which Bob measures a 1 over all the possible combinations. This is done with the marginal_counts method from qiskit.result, which combines results over measurement indices.\n\n\nMarginalisation\nEx 4 - Marginalize the teleported counts\nHint: Remember that bit strings are reported in the little-endian convention.\n\njob_static.result().quasi_dists[0]\n\n{1: 0.806640625, 0: 0.193359375}\n\n\n\njob_static.result()\n\nSamplerResult(quasi_dists=[{1: 0.806640625, 0: 0.193359375}], metadata=[{'shots': 1024, 'simulator_metadata': {'parallel_state_update': 12, 'parallel_shots': 1, 'sample_measure_time': 0.000272645, 'noise': 'ideal', 'batched_shots_optimization': False, 'remapped_qubits': False, 'device': 'CPU', 'active_input_qubits': [0], 'measure_sampling': True, 'num_clbits': 1, 'input_qubit_map': [[0, 0]], 'num_qubits': 1, 'method': 'statevector', 'fusion': {'applied': False, 'max_fused_qubits': 5, 'threshold': 14, 'enabled': True}}}])\n\n\n\nresult_dynamic = job_dynamic.result().quasi_dists[0].binary_probabilities()\n\n\nprint(result_dynamic)\n\n{'011': 0.03515625, '111': 0.2001953125, '001': 0.05078125, '110': 0.1826171875, '100': 0.208984375, '101': 0.2431640625, '000': 0.0341796875, '010': 0.044921875}\n\n\n\n## Index should be 2 because we want to measure Bob's bit, left most bit e.g. in 100, Bob's bit is 1\nfrom qiskit.result import marginal_counts\n\n\ntele_counts = marginal_counts(result_dynamic, indices=[2])# marginalize counts\n\n\ntele_counts\n\n{'0': 0.1650390625, '1': 0.8349609375}\n\n\n\nfrom qiskit.visualization import plot_histogram\nlegend = ['Original State', 'Teleported State']\nplot_histogram([job_static.result().quasi_dists[0].binary_probabilities(), tele_counts], legend=legend)\n\n\n\n\n\nimport qiskit.tools.jupyter\n%qiskit_version_table\n\nVersion Information\n\n\n\nQiskit Software\nVersion\n\n\nqiskit-terra\n0.24.0\n\n\nqiskit-aer\n0.12.0\n\n\nqiskit-ibmq-provider\n0.20.2\n\n\nqiskit\n0.43.0\n\n\nSystem information\n\n\n\nPython version\n3.8.3\n\n\nPython compiler\nClang 10.0.0\n\n\nPython build\ndefault, Jul 2 2020 11:26:31\n\n\nOS\nDarwin\n\n\nCPUs\n6\n\n\nMemory (Gb)\n16.0\n\n\nSat Jul 22 22:53:52 2023 IST"
  },
  {
    "objectID": "posts/Entanglement/lab2.html",
    "href": "posts/Entanglement/lab2.html",
    "title": "Entanglement and CHSH Inequality",
    "section": "",
    "text": "How quantum mechnaics can‚Äôt be described by the hidden variable theory."
  },
  {
    "objectID": "posts/Entanglement/lab2.html#getting-started",
    "href": "posts/Entanglement/lab2.html#getting-started",
    "title": "Entanglement and CHSH Inequality",
    "section": "Getting Started",
    "text": "Getting Started\nStart by importing some libraries we need, including the Sampler and Estimator primitives from Qiskit. While the primitives from qiskit.providers use a local statevector simulator by default, the syntax within this lab is easily generalizable to running experiments on real systems.\nTo run on real hearware requires a Qiskit Runtime service instance. If you haven‚Äôt done so already, follow the instructions in the Qiskit Getting started guide to set one up. TODO: include video links and such. After setup, import the Sampler and Estimator primitives from qiskit_ibm_runtime instead. Additionally we will need QiskitRuntimeService and Session, which form the interface between Qiskit and Qiskit IBM Runtime. Then the below exercises can be run on real systems by instantiating the primitives in this way (as opposed to from qiskit.primitives):\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler, Estimator\n\nservice = QiskitRuntimeService()\nbackend = service.get_backend('...')\nsession = Session(service=service, backend=backend)\nsampler = Sampler(session=session)\nestimator = Estimator(session=session)\nwhere additional options can be specified in the Sampler and Estimator with the Options class. See this how-to for using Primitives with Runtime Sessions.\n\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.primitives import Estimator, Sampler\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.visualization import plot_histogram\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('dark_background') # optional"
  },
  {
    "objectID": "posts/Entanglement/lab2.html#chsh-inequality-violation",
    "href": "posts/Entanglement/lab2.html#chsh-inequality-violation",
    "title": "Entanglement and CHSH Inequality",
    "section": "CHSH Inequality Violation",
    "text": "CHSH Inequality Violation\n\nWarm Up\nCreate circuits that put the qubit in the excited \\(|1\\rangle\\) and superposition \\(|+\\rangle\\) states, respectivly, and measure them in different bases. This is done first with the Sampler primitive (which is most similar to the backend.run() used in the previous lab), and then with the Estimator primitive to show how measurement is abstracted in that we do not need to worry about rotating the qubit into the appropriate measurement basis. The primitives will be executed withing the Session context which allows efficiency to optimize workloads.\n\n# create excited |1&gt; state\nqc_1 = QuantumCircuit(1)\nqc_1.x(0)\nqc_1.draw('mpl')\n\n\n\n\n\n# create superposition |+&gt; state\nqc_plus = QuantumCircuit(1)\nqc_plus.h(0)\nqc_plus.draw('mpl')\n\n\n\n\n\n\nSampler Primitive\nFirst use the Sampler to measure qubits in the \\(Z\\)-basis (the physical basis in which qubits are measured). The Sampler will count the number of outcomes of the \\(|0\\rangle\\) state and \\(|1\\rangle\\) state, normalized by the number of shots (experiments performed). The Sampler also offers the ability to easily perform error mitigation (which is covered in Lab 5), which modifies this calculation, and hence the outcomes are refered to as quasi-probabilities.\nMeasurments must be present in the circuit when using the Sampler primitive. Then the Session context is opened, the Sampler is instantiated, and sampler.run() is used to send the circuits to the backend, similar to the backend.run() syntax you may already be familiar with.\n\nqc_1.measure_all()\nqc_plus.measure_all()\n\nsampler = Sampler()\njob_1 = sampler.run(qc_1)\njob_plus = sampler.run(qc_plus)\n\n\njob_1.result().quasi_dists\n\n[{1: 1.0}]\n\n\n\njob_plus.result().quasi_dists\n\n[{0: 0.4999999999999999, 1: 0.4999999999999999}]\n\n\n\nlegend = [\"Excited State\", \"Plus State\"] # TODO: Excited State does not appear\nplot_histogram([job_1.result().quasi_dists[0], job_plus.result().quasi_dists[0]], legend=legend)\n\n\n\n\nThe result for the excited state is always \\(|1\\rangle\\) wheres it is roughly half \\(|0\\rangle\\) and half \\(|1\\rangle\\) for the plus superposition state. This is because the \\(|0\\rangle\\) and \\(|1\\rangle\\) states are eigenstates of the \\(Z\\) operator (with \\(+1\\) and \\(-1\\) eigenvalues, respectively).\nLet‚Äôs switch and measure in the \\(X\\) basis. Using the Sampler we must rotate the qubit from the \\(X\\)-basis to the \\(Z\\)-basis for measurement (because that is the only basis we can actually perform measurement in).\n\nqc_1.remove_final_measurements()\nqc_plus.remove_final_measurements()\n\n# rotate into the X-basis\nqc_1.h(0)\nqc_plus.h(0)\n\nqc_1.measure_all()\nqc_plus.measure_all()\n\n\nsampler = Sampler()\njob_1 = sampler.run(qc_1)\njob_plus = sampler.run(qc_plus)\n\n\nplot_histogram([job_1.result().quasi_dists[0], job_plus.result().quasi_dists[0]], legend=legend)\n\n\n\n\nNow we see the opposite: the plus superposition always give the 1 result, hence an eigenstate of the \\(X\\) operator, whereas the excited \\(|1\\rangle\\) yields a roughtly fifty-fifty split. The \\(|+\\rangle\\) and \\(|-\\rangle\\) states are eigenstates of the \\(X\\) operator, with eigenvalues \\(+1\\) and \\(-1\\), respectively. This is good to remember when considering how the Estimator works in the next subsection.\n\n\nEstimator Primitive\nThe Qiskit Runtime Primitives allow us to abstract measurement into the Estimator primitive, where it is specified as an observable. In particular, we can construct the same circuits, the excited \\(|1\\rangle\\) and superposition \\(|+\\rangle\\) as before. However, in the case of the Estimator, we do not add measurements to the circuit. Instead, specify a list of observables which take the form of Pauli strings. In our case for a measurement of a single qubit, we specify 'Z' for the \\(Z\\)-basis and 'X' for the \\(X\\)-basis.\n\nqc2_1 = QuantumCircuit(1)\nqc2_1.x(0)\n\nqc2_plus = QuantumCircuit(1)\nqc2_plus.h(0)\n\nobsvs = list(SparsePauliOp(['Z', 'X']))\n\n\nestimator = Estimator()\njob2_1 = estimator.run([qc2_1]*len(obsvs), observables=obsvs)\njob2_plus = estimator.run([qc2_plus]*len(obsvs), observables=obsvs)\n\n\njob2_1.result()\n\nEstimatorResult(values=array([-1.,  0.]), metadata=[{}, {}])\n\n\n\n# TODO: make this into module that outputs a nice table\nprint(f'    |   &lt;Z&gt;   |   &lt;X&gt; ')\nprint(f'----|------------------')\nprint(f'|1&gt; | {job2_1.result().values[0]}    | {job2_1.result().values[1]}')\nprint(f'|+&gt; | {job2_plus.result().values[0]} | {job2_plus.result().values[1]}')\n\n    |   &lt;Z&gt;   |   &lt;X&gt; \n----|------------------\n|1&gt; | -1.0    | 0.0\n|+&gt; | 0.0 | 0.9999999999999998\n\n\nJust as before, we see the \\(|1\\rangle\\) state expectation in the \\(Z\\)-basis is \\(-1\\) (corresponding to its eigenvalue) and around zero in the \\(X\\)-basis (average over \\(+1\\) and \\(-1\\) eigenvalues), and vice-versa for the \\(|+\\rangle\\) state (although its eigenvalue of the \\(X\\) operators is \\(+1\\))."
  },
  {
    "objectID": "posts/Entanglement/lab2.html#chsh-inequality",
    "href": "posts/Entanglement/lab2.html#chsh-inequality",
    "title": "Entanglement and CHSH Inequality",
    "section": "CHSH Inequality",
    "text": "CHSH Inequality\nImagine Alice and Bob are given each one part of a bipartite entangled system. Each of them then performs two measurements on their part in two different bases. Let‚Äôs call Alice‚Äôs bases A and a and Bob‚Äôs B and b. What is the expectation value of the quantity\n\\[\n\\langle CHSH \\rangle = \\langle AB \\rangle - \\langle Ab \\rangle + \\langle aB \\rangle + \\langle ab \\rangle ?\n\\]\nNow, Alice and Bob have one qubit each, so any measurement they perform on their system (qubit) can only yield one of two possible outcomes: +1 or -1. Note that whereas we typically refer to the two qubit states as \\(|0\\rangle\\) and \\(|1\\rangle\\), these are eigenstates, and a projective measurement will yield their eigenvalues, +1 and -1, respectively.\nTherefore, if any measurement of A, a, B, and b can only yield \\(\\pm 1\\), the quantities \\((B-b)\\) and \\((B+b)\\) can only be 0 or \\(\\pm 2\\). And thus, the quantity \\(A(B-b) + a(B+b)\\) can only be either +2 or -2, which means that there should be a bound for the expectation value of the quantity we have called\n\\[\n|\\langle CHSH \\rangle| = |\\langle AB \\rangle - \\langle Ab \\rangle + \\langle aB \\rangle + \\langle ab \\rangle| \\le 2.\n\\]\nNow, the above discussion is oversimplified, because we could consider that the outcome on any set of measurements from Alice and Bob could depend on a set of local hidden variables, but it can be shown with some math that, even when that is the case, the expectation value of the quantity \\(CHSH\\) should be bounded by 2 if local realism held.\nBut what happens when we do these experiments with an entangled system? Let‚Äôs try it!\nThe first step is to build the observable \\[\nCHSH = A(B-b) + a(B+b) = AB - Ab + aB +ab\n\\] where \\(A, a\\) are each one of \\(\\{IX, IZ\\}\\) for qubit 0 and \\(B, b\\) are each one of \\(\\{XI, ZI\\}\\) for qubit 1 (corresponding to little-endian notation). Paulis on different qubits can be composed by specifying order with a Pauli string, for example instantiating a SparsePauliOp with the 'ZX' argument implies a measurement of \\(\\langle X \\rangle\\) on q0 and \\(\\langle Z \\rangle\\) on q1 . This tensor product (combining operations on different qubits) can be explicitly stated using the .tensor() method. Additionally, combining operations on the same qubit(s) uses the compositional product with the .compose() method. For example, all these statements create the same Pauli operator:\nfrom qiskit.quantum_info import SparsePauliOp\n\nZX = SparsePauliOp('ZX')\nZX = SparsePauliOp(['ZX'], coeffs=[1.]) # extendable to a sum of Paulis\nZX = SparsePauliOp('Z').tensor(SparsePauliOp('X')) # extendable to a tensor product of Paulis\nZX = SparsePauliOp('XZ').compose(SparsePauliOp('YY')) # extendable to a compositional product of Paulis\nEx 1 - create an operator for CHSH witness\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Session\n\n\nZZ = SparsePauliOp.from_list([(\"ZZ\", 1)])\nZX = SparsePauliOp.from_list([(\"ZX\", 1)])\nXZ = SparsePauliOp.from_list([(\"XZ\", 1)])\nXX = SparsePauliOp.from_list([(\"XX\", 1)])\n\n\nZZ +ZX\n\nSparsePauliOp(['ZZ', 'ZX'],\n              coeffs=[1.+0.j, 1.+0.j])\n\n\n\nobsv = ZZ - ZX + XZ + XX # create operator for chsh witness\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab2_ex1\n\ngrade_lab2_ex1(obsv)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nCreate Entangled Qubit Pair\nNext we want to test the \\(CHSH\\) observable on an entangled pair, for example the maximally-entangled Bell state \\[\n|\\Phi\\rangle = \\frac{1}{\\sqrt{2}} \\left(|00\\rangle + |11\\rangle \\right)\n\\] which is created with a Hadamard gate followed by a CNOT with the target on the same qubit as the Hadamard. Due to the simplifaction of measuring in just the \\(X\\)- and \\(Z\\)-bases as discussed above, we will rotate the Bell state around the Bloch sphere which is equivalant to changing the measurement basis as demonstrated in the Warmup section. This can be done by applying an \\(R_y(\\theta)\\) gate where \\(\\theta\\) is a Parameter to be specified at the Estimator API call. This produces the state \\[\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}} \\left(\\cos(\\theta/2) |00\\rangle + \\sin(\\theta/2)|11\\rangle \\right)\n\\]\n\nfrom qiskit.circuit import Parameter\n\ntheta = Parameter('Œ∏')\n\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.ry(theta, 0)\n\nqc.draw('mpl')\n\n\n\n\nNext we need to specify a Sequence of Parameters that show a clear violation of the CHSH Inequality, namely \\[\n|\\langle CHSH \\rangle| &gt; 2.\n\\] Let‚Äôs make sure we have at least three points in violation.\nEx 2 - Create a Parameterization (i.e., list, array) of the angle in the above circuit (in radians)\nHint: Note the type for the parameter_values argument is Sequence[Sequence[float]].\n\nnumber_of_phases = 25\nphases = np.linspace(0, 2 * np.pi, number_of_phases)\nangles = []\nfor p in phases:\n    angles.append([p])   \nangles\n\n[[0.0],\n [0.2617993877991494],\n [0.5235987755982988],\n [0.7853981633974483],\n [1.0471975511965976],\n [1.308996938995747],\n [1.5707963267948966],\n [1.832595714594046],\n [2.0943951023931953],\n [2.356194490192345],\n [2.617993877991494],\n [2.8797932657906435],\n [3.141592653589793],\n [3.4033920413889422],\n [3.665191429188092],\n [3.926990816987241],\n [4.1887902047863905],\n [4.45058959258554],\n [4.71238898038469],\n [4.974188368183839],\n [5.235987755982988],\n [5.497787143782138],\n [5.759586531581287],\n [6.021385919380436],\n [6.283185307179586]]\n\n\nTest your angles and observable by running with the Estimator before submitting to the grader.\n\nfrom qiskit.primitives import Estimator, Sampler\n\n\nestimator = Estimator()\njob = estimator.run([qc]*len(angles), observables=[obsv]*len(angles), parameter_values=angles)\nexps = job.result().values\n\nplt.plot(angles, exps, marker='x', ls='-', color='green')\nplt.plot(angles, [2]*len(angles), ls='--', color='red', label='Classical Bound')\nplt.plot(angles, [-2]*len(angles), ls='--', color='red')\nplt.xlabel('angle (rad)')\nplt.ylabel('CHSH Witness')\nplt.legend(loc=4)\n\n&lt;matplotlib.legend.Legend at 0x7fcb80419060&gt;\n\n\n\n\n\nDid you see at least 3 points outside the red dashed lines? If so, you are ready to send to the grader!\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab2_ex2\n\ngrade_lab2_ex2(obsv, angles)\n\nSubmitting your answer. Please wait...\nCongratulations üéâ! Your answer is correct and has been submitted.\n\n\n\nimport qiskit.tools.jupyter\n%qiskit_version_table\n\nVersion Information\n\n\n\nQiskit Software\nVersion\n\n\nqiskit-terra\n0.24.1\n\n\nqiskit-aer\n0.12.1\n\n\nqiskit-ibmq-provider\n0.20.2\n\n\nqiskit\n0.43.2\n\n\nqiskit-nature\n0.6.2\n\n\nqiskit-finance\n0.3.4\n\n\nqiskit-optimization\n0.5.0\n\n\nqiskit-machine-learning\n0.6.1\n\n\nSystem information\n\n\n\nPython version\n3.10.8\n\n\nPython compiler\nGCC 10.4.0\n\n\nPython build\nmain, Nov 22 2022 08:26:04\n\n\nOS\nLinux\n\n\nCPUs\n8\n\n\nMemory (Gb)\n31.211322784423828\n\n\nFri Jul 21 19:11:24 2023 UTC"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "|quantum learnings>",
    "section": "",
    "text": "Dirac Notation and Quantum Circuits\n\n\n\n\n\n\n\nquantum theory\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nJul 17, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\n  \n\n\n\n\nHeisenberg‚Äôs Uncertainty Principle\n\n\n\n\n\n\n\nquantum theory\n\n\n\n\n\n\n\n\n\n\n\nJun 12, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\n  \n\n\n\n\nQuantum Teleportation\n\n\n\n\n\n\n\nquantum theory\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nJun 6, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\n  \n\n\n\n\nEntanglement and CHSH Inequality\n\n\n\n\n\n\n\nquantum theory\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nMay 28, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\nNo matching items"
  }
]