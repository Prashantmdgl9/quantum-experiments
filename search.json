[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/test post/Single Qubit Gates and Heisenberg Principl.html",
    "href": "posts/test post/Single Qubit Gates and Heisenberg Principl.html",
    "title": "Heisenberg’s Uncertainty principle",
    "section": "",
    "text": "---\ntitle: \"Heisenberg\"\nauthor: \"Prashant\"\ndate: \"2023-07-08\"\n---\n\n\nfrom qiskit import QuantumCircuit, assemble, Aer\nfrom math import pi, sqrt\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nsim = Aer.get_backend('aer_simulator')\n\n\n# Let's do an X-gate on a |0&gt; qubit\nqc = QuantumCircuit(1)\nqc.x(0)\nqc.draw()\n\n   ┌───┐\nq: ┤ X ├\n   └───┘\n\n\n\n# Let's see the result\nqc.save_statevector()\nstate = sim.run(qc).result().get_statevector()\nplot_bloch_multivector(state)\n\n\n\n\nThe state hs been changed from 0 to 1, thats what X gate does\n\nqc.y(0) # Do Y-gate on qubit 0\nqc.z(0) # Do Z-gate on qubit 0\nqc.draw()\n\n   ┌───┐ statevector ┌───┐┌───┐\nq: ┤ X ├──────░──────┤ Y ├┤ Z ├\n   └───┘      ░      └───┘└───┘\n\n\n\n# Create the X-measurement function:\ndef x_measurement(qc, qubit, cbit):\n    \"\"\"Measure 'qubit' in the X-basis, and store the result in 'cbit'\"\"\"\n    qc.h(qubit)\n    qc.measure(qubit, cbit)\n    return qc\n\ninitial_state = [1/sqrt(2), -1/sqrt(2)]\n# Initialize our qubit and measure it\nqc = QuantumCircuit(1,1)\nqc.initialize(initial_state, 0)\nx_measurement(qc, 0, 0)  # measure qubit 0 to classical bit 0\nqc.draw()\n\n     ┌──────────────────────────────┐┌───┐┌─┐\n  q: ┤ Initialize(0.70711,-0.70711) ├┤ H ├┤M├\n     └──────────────────────────────┘└───┘└╥┘\nc: 1/══════════════════════════════════════╩═\n                                           0 \n\n\n\ncounts = sim.run(qc).result().get_counts()  # Do the simulation, returning the state vector\nplot_histogram(counts)  # Display the output on measurement of state vector\n\n\n\n\nWe initialized our qubit in - the state , but we can see that, after the measurement, we have collapsed our qubit to the 1 state . If you run the cell again, you will see the same result, since along the X-basis, the state - is a basis state and measuring it along X will always yield the same result.\nMeasuring in different bases allows us to see Heisenberg’s famous uncertainty principle in action. Having certainty of measuring a state in the Z-basis removes all certainty of measuring a specific state in the X-basis, and vice versa. A common misconception is that the uncertainty is due to the limits in our equipment, but here we can see the uncertainty is actually part of the nature of the qubit.\nhttps://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-states/old-unique-properties-qubits.ipynb\n\nfrom qiskit import *\nfrom qiskit.visualization import plot_histogram\n%config InlineBackend.figure_format = 'svg' # Makes the images look nice\n\n\nmeasure_z = QuantumCircuit(1,1)\nmeasure_z.measure(0,0)\n\nmeasure_z.draw(output='mpl')\n\n\n\n\n\nmeasure_x = QuantumCircuit(1,1)\nmeasure_x.h(0)\nmeasure_x.measure(0,0)\n\nmeasure_x.draw(output='mpl')\n\n\n\n\n\nqc_0 = QuantumCircuit(1)\n\nqc_0.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_z, qc_0)\n\nqc.draw()\n\n     ┌─┐\n  q: ┤M├\n     └╥┘\nc: 1/═╩═\n      0 \n\n\n\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\n\n\ncounts\n\n{'0': 1024}\n\n\n\nprint('Results for z measurement:')\n\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_x, qc_0)\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ┌───┐┌─┐\n  q: ┤ H ├┤M├\n     └───┘└╥┘\nc: 1/══════╩═\n           0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\n\nqc_plus = QuantumCircuit(1)\nqc_plus.h(0)\n\nqc_plus.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_z)\n\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ┌───┐┌─┐\n  q: ┤ H ├┤M├\n     └───┘└╥┘\nc: 1/══════╩═\n           0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n\n     ┌───┐┌───┐┌─┐\n  q: ┤ H ├┤ H ├┤M├\n     └───┘└───┘└╥┘\nc: 1/═══════════╩═\n                0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two.\n\nOther rotations\n\nqc_y = QuantumCircuit(1)\nqc_y.ry( -3.14159/4,0)\n\nqc_y.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_y, measure_z)\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ┌─────────────┐┌─┐\n  q: ┤ Ry(-0.7854) ├┤M├\n     └─────────────┘└╥┘\nc: 1/════════════════╩═\n                     0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\nHere we have a case that we have not seen before. The z measurement is most likely to output 0, but it is not completely certain. A similar effect is seen below for the x measurement: it is most likely, but not certain, to output 1.\n\nqc = QuantumCircuit.compose(qc_y, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     ┌─────────────┐┌───┐┌─┐\n  q: ┤ Ry(-0.7854) ├┤ H ├┤M├\n     └─────────────┘└───┘└╥┘\nc: 1/═════════════════════╩═\n                          0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "quantum-experiments",
    "section": "",
    "text": "Heisenberg’s Uncertainty principle\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nPost With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nJul 22, 2023\n\n\nHarlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nJul 19, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]