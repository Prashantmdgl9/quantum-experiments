[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Prashant Mudgal",
    "section": "",
    "text": "In this blog, I am documenting my learning journey in quantum computing and quantum mechanics.\nI am mainly writing for myself, trying to explain/clarify concepts to myself while writing and crystallising them for future use too.\nThrough this blog, I am implementing the concept of â€œThe Best Way to Learn s to Teachâ€.\nIf you stumbled across this blog and you find it useful, then thatâ€™s destiny :)"
  },
  {
    "objectID": "posts/Dirac/lab1.html",
    "href": "posts/Dirac/lab1.html",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "",
    "text": "Getting started with Dirac notation and qiskit circuits"
  },
  {
    "objectID": "posts/Dirac/lab1.html#vectors-and-dirac-notation",
    "href": "posts/Dirac/lab1.html#vectors-and-dirac-notation",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Vectors and Dirac Notation",
    "text": "Vectors and Dirac Notation\nIn the lectures you learned different ways of representing quantum states, including how to use bra-ket (Dirac) notation.\nAlthough bra-ket notation cannot be represented exactly in code, we can represent their vector and matrix equivalent with python.\nE.g. we can represent \\(|0\\rangle\\) using a python list:\n\nket0 = [[1],[0]]\n\nAnd we can use one of Qiskitâ€™s visualisation tools to make our vectors nicer to look at:\n\narray_to_latex(ket0)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can do the same with \\(\\langle0|\\):\n\nbra0 = [1,0]\narray_to_latex(bra0)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 1 - create \\(|1\\rangle\\) and \\(\\langle1|\\) with python lists\n\n\nket1 = [[0], [1]]\nbra1 = [0 , 1]\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex1 \n\ngrade_lab1_ex1([ket1, bra1])\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#qiskit-statevector-class",
    "href": "posts/Dirac/lab1.html#qiskit-statevector-class",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Qiskit Statevector Class",
    "text": "Qiskit Statevector Class\nIn the lectures you learned about using state vectors to represent quantum states. You can represent quantum state vectors in code using Qiskitâ€™s Statevector class.\nQiskitâ€™s Statevector class can take different forms of input (e.g.Â python list, numpy array, another state vector) to construct a state vector.\nLetâ€™s take the bra0 object we created earlier and convert it to a Statevector object:\n\nsv_bra0 = Statevector(bra0)\n\nsv_bra0\n\nStatevector([1.+0.j, 0.+0.j],\n            dims=(2,))\n\n\nThe Statevector class has its own draw() method:\n\nsv_bra0.draw('latex')\n\n\\[ |0\\rangle\\]\n\n\nWe can create more complex statevectors with multiple qubits like this:\n\nsv_eq = Statevector([1/2, 3/4, 4/5, 6/8])\n\nsv_eq.draw('latex')\n\n\\[\\frac{1}{2} |00\\rangle+\\frac{3}{4} |01\\rangle+\\frac{4}{5} |10\\rangle+\\frac{3}{4} |11\\rangle\\]\n\n\nNote that the vector above is not a valid state vector as it is not normalised. We can check this with the is_valid() method:\n\nsv_eq.is_valid()\n\nFalse\n\n\n\nEx 2 - create your own valid statevector object using the Statevector class\n\n\nsv_valid = Statevector([1/2, 1/2, 1/2, 1/2])\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex2 \n\ngrade_lab1_ex2(sv_valid)\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#qiskit-operator-class",
    "href": "posts/Dirac/lab1.html#qiskit-operator-class",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Qiskit Operator Class",
    "text": "Qiskit Operator Class\nThe Operator class is used in Qiskit to represent matrix operators acting on a quantum system. It has several methods to build composite operators using tensor products of smaller operators, and to compose operators.\nOne way we can initialise a Qiskit Operator is by using a python list, like the one we created earlier:\n\nop_bra0 = Operator(bra0)\n\nop_bra0\n\nOperator([1.+0.j, 0.+0.j],\n         input_dims=(), output_dims=(2,))\n\n\nThe Operator class comes with some handy methods for working with operators, for example we can find the tensor product of 2 operators by using the tensor() method:\n\nop_ket0 = Operator(ket0)\nop_bra0.tensor(op_ket0)\n\nOperator([[1.+0.j, 0.+0.j],\n          [0.+0.j, 0.+0.j]],\n         input_dims=(), output_dims=(2, 2))\n\n\n\nop_ket0\n\nOperator([[1.+0.j],\n          [0.+0.j]],\n         input_dims=(), output_dims=(2,))\n\n\n\nop_ket0.tensor(op_bra0)\n\nOperator([[1.+0.j, 0.+0.j],\n          [0.+0.j, 0.+0.j]],\n         input_dims=(), output_dims=(2, 2))\n\n\nWeâ€™ll use the Operator and Statevector classes more in the following exercises."
  },
  {
    "objectID": "posts/Dirac/lab1.html#inner-outer-product",
    "href": "posts/Dirac/lab1.html#inner-outer-product",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Inner & Outer Product",
    "text": "Inner & Outer Product\nIn the lectures you covered the concepts of the inner and outer product. We can explore these concepts in code using numpy methods .dot() (the inner product is a generalised form of the dot product) and .outer().\nFor example, we can find the inner product \\(\\langle0|0\\rangle\\) like this:\n\nbraket = np.dot(op_bra0,op_ket0)\narray_to_latex(braket)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nand the outer product \\(|0\\rangle\\langle0|\\) like this:\n\nketbra = np.outer(ket0,bra0)\narray_to_latex(ketbra)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nbraket = np.dot(op_bra0,op_ket0)\narray_to_latex(braket)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nNote: the numpy methods we used above work with Qiskit Operators as well as regular python lists.\n\nEx 3 - use numpy to find the result of the following inner and outer products: \\(\\langle1|0\\rangle, \\langle0|1\\rangle, \\langle1|1\\rangle, |1\\rangle\\langle0|, |0\\rangle\\langle1|\\) and $|1| $\n\n\nbra1ket0 = np.dot(bra1,ket0)# put your answer for âŸ¨1|0âŸ© here\n\nbra0ket1 = np.dot(bra0,ket1)# put your answer for âŸ¨0|1âŸ© here\n\nbra1ket1 = np.dot(bra1,ket1)# put your answer for âŸ¨1|1âŸ© here\n\nket1bra0 = np.outer(ket1,bra0)# put your answer for |1âŸ©âŸ¨0| here\n\nket0bra1 = np.outer(ket0,bra1) # put your answer for |0âŸ©âŸ¨1| here\n\nket1bra1 = np.outer(ket1,bra1)# put your answer for |1âŸ©âŸ¨1| here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex3 \n\ngrade_lab1_ex3([bra1ket0, bra0ket1, bra1ket1, ket1bra0, ket0bra1, ket1bra1])\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted.\n\n\n\nnp.dot(ket1, ket1)\n\nTraceback (most recent call last):\n  Cell In[30], line 1\n    np.dot(ket1, ket1)\n  File &lt;__array_function__ internals&gt;:180 in dot\nValueError: shapes (2,1) and (2,1) not aligned: 1 (dim 1) != 2 (dim 0)\n\nUse %tb to get the full traceback.\n\n\n\n\nSearch for solution online\n\n\n\n&lt;p&gt; Ex 4 - when the inner product of 2 quantum states is equal to 0, those states are orthogonal. Which of the following states are orthogonal? &lt;/p&gt;\n&lt;p&gt;a) $\\vert 0\\rangle$ and $\\vert 1\\rangle$ &lt;/p&gt;\n&lt;p&gt;b) $\\vert 0\\rangle$ and $\\vert 0\\rangle$ &lt;/p&gt;\n&lt;p&gt;c) $\\vert 1\\rangle$ and $\\vert 1\\rangle$ &lt;/p&gt;\n\n\n# add or remove your answer from this list\nanswer = ['a']\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex4 \n\ngrade_lab1_ex4(answer)\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#deterministic-operations",
    "href": "posts/Dirac/lab1.html#deterministic-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Deterministic operations",
    "text": "Deterministic operations\nAs mentioned in the lectures, there are 4 single bit deterministic operations:\nf1 = constant-0\nf2 = identity\nf3 = bit flip / not\nf4 = constant-1\n\\[\n\\begin{array}{c|c}\n  a & f_1(a)\\\\\n  \\hline\n  0 & 0\\\\\n  1 & 0\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_2(a)\\\\\n  \\hline\n  0 & 0\\\\\n  1 & 1\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_3(a)\\\\\n  \\hline\n  0 & 1\\\\\n  1 & 0\n\\end{array}\n\\qquad\n\\begin{array}{c|c}\n  a & f_4(a)\\\\\n  \\hline\n  0 & 1\\\\\n  1 & 1\n\\end{array}\n\\]\nWe can create Qiskit Operators for these 4 operations, by passing their matrix representations as arguments to the Operator class.\nE.g. for constant-0 we can create the corresponding matrix m1 like so:\n\nm1 = Operator([[1,1],[0,0]])\narray_to_latex(m1)\n\n$$\n\\[\\begin{bmatrix}\n1 & 1  \\\\\n0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nand similarly for m3:\n\nm3 = Operator([[0,1],[1,0]])\narray_to_latex(m3)\n\n$$\n\\[\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can also use builtin python mutliplication operations (e.g.Â @, .dot, or .matmul) to check the following equation: $ M|a= f|a$\ne.g.Â $ M1|0= f1|0$ = 0\n\narray_to_latex(m1@ket0)\n\n$$\n\\[\\begin{bmatrix}\n1  \\\\\n0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 5 - create Qiskit Operators for m2 and m4 (hint: check out the lectures to find the appropriate matrices)\n\n\nm2 =  Operator([[1,0],[0,1]]) # create an operator for m2 here\nm4 =  Operator([[0,0],[1,1]])# create and operator for m4 here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex5\n\ngrade_lab1_ex5([m2, m4])\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#probabilistic-operations",
    "href": "posts/Dirac/lab1.html#probabilistic-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Probabilistic operations",
    "text": "Probabilistic operations\nA Controlled-NOT (or CNOT) operation is a probabilistic operation you can apply on 2 qubits.\nApplying a CNOT on a state (X,Y) involves performing a NOT operation on Y when X is 1, otherwise do nothing. X is the control bit, Y is the target bit.\nWe can implement a CNOT gate (and many other quantum gates) using a class from Qiskitâ€™s circuit library:\n\ncnot = CXGate()\n\narray_to_latex(cnot)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0 & 0 & 0  \\\\\n0 & 0 & 0 & 1  \\\\\n0 & 0 & 1 & 0  \\\\\n0 & 1 & 0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nNote: this matrix is different from the one that appeared in the lesson because CXGate() takes the right qubit to be the control rather than the left qubit."
  },
  {
    "objectID": "posts/Dirac/lab1.html#unitary-operations",
    "href": "posts/Dirac/lab1.html#unitary-operations",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Unitary Operations",
    "text": "Unitary Operations\nAn operator is unitary if: $ UU^{} = = U^{} U$\nWe can check if an operator is Unitary using Qiskit with the is_unitary() method:\n\nm3.is_unitary()\n\nTrue\n\n\nWith small operators like m3 we could probably figure this out easily by ourselves, but with more complex operators it becomes more convenient to use the Qiskit function:\n\nrandom = Operator(np.array([[ 0.50778085-0.44607116j, -0.1523741 +0.14128434j,  0.44607116+0.50778085j,\n  -0.14128434-0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j, -0.12151822+0.16855994j,\n  -0.38038841+0.55868196j],\n [ 0.50778085-0.44607116j, -0.1523741 +0.14128434j, -0.44607116-0.50778085j,\n   0.14128434+0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j,  0.12151822-0.16855994j,\n   0.38038841-0.55868196j]]))\n\nrandom.is_unitary()\n\nTrue\n\n\n\nEx 6 - create an operator using the Operator class that is not unitary\n\n\nnon_unitary_op = Operator(np.array([[ 0.52778085-0.49607116j, -0.1523741 +0.14128434j,  0.44607116+0.50778085j,\n  -0.14128434-0.1523741j ],\n [ 0.16855994+0.17151822j,  0.55868196+0.38038841j, -0.12151822+0.16855994j,\n  -0.38038841+0.55868196j],\n [ 0.50778085-0.44607116j, -0.1523741 +0.14128434j, -0.44607116-0.50778085j,\n   0.14128434+0.1523741j ],\n [ 0.16855994+0.12151822j,  0.55868196+0.38038841j,  0.12151822-0.16855994j,\n   0.38038841-0.55868196j]]))# create your operator here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex6\n\ngrade_lab1_ex6(non_unitary_op)\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted.\n\n\n\nQubit Unitary Operations - Pauli Operations\nSome of the most common unitary operations in quantum computing are the Pauli operations. Qiskitâ€™s Pauli classes make it easy to interact with Pauli operators in code:\nE.g. Pauli X (\\(\\sigma_x\\)), the bit flip:\n\npauli_x = Pauli('X')\n\narray_to_latex(pauli_x)\n\n$$\n\\[\\begin{bmatrix}\n0 & 1  \\\\\n1 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nPauli Y (\\(\\sigma_y\\)):\n\npauli_y = Pauli('Y')\n\narray_to_latex(pauli_y)\n\n$$\n\\[\\begin{bmatrix}\n0 & - i  \\\\\ni & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nPauli Z (\\(\\sigma_z\\)), the phase flip:\n\npauli_z = Pauli('Z')\n\narray_to_latex(pauli_z)\n\n$$\n\\[\\begin{bmatrix}\n1 & 0  \\\\\n0 & -1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nWe can use the Operator class with the Pauli class:\n\nop_x = Operator(pauli_x)\n\nop_x\n\nOperator([[0.+0.j, 1.+0.j],\n          [1.+0.j, 0.+0.j]],\n         input_dims=(2,), output_dims=(2,))\n\n\nLetâ€™s use the Operator class and numpy to find the outcome of \\(\\sigma_x|0\\rangle\\)\n\nop_new = np.dot(op_x,ket0)\n\narray_to_latex(op_new)\n\n$$\n\\[\\begin{bmatrix}\n0  \\\\\n1  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nop_z = Operator(pauli_z)\n\nop_z\n\nOperator([[ 1.+0.j,  0.+0.j],\n          [ 0.+0.j, -1.+0.j]],\n         input_dims=(2,), output_dims=(2,))\n\n\n\nEx 7 - Apply the Pauli-Z operator on \\(|1\\rangle\\)\n\n\nresult = np.dot(op_z, ket1) # do your operations here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex7\n\ngrade_lab1_ex7(result)\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted.\n\n\n\n\nQubit Unitary Operations - Hadamard\nThe Hadamard gate is one of the most important unitary operations in quantum computing. We can implement a Hadamard gate (and many other quantum gates) using a class from Qiskitâ€™s circuit library:\n\nhadamard = HGate()\n\narray_to_latex(hadamard)\n\n$$\n\\[\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n\\end{bmatrix}\\]\n$$\n\n\nYou can convert many Qiskit classes to operators to make use of functions specific to the Operator class, such as is_unitary\n\nhop = Operator(hadamard)\nhop.is_unitary()\n\nTrue"
  },
  {
    "objectID": "posts/Dirac/lab1.html#quantum-circuits",
    "href": "posts/Dirac/lab1.html#quantum-circuits",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Quantum Circuits",
    "text": "Quantum Circuits\nIn the lectures you learned how to create a Quantum Circuit using a CNOT and a Hadamard gate. This circuit creates the Bell State \\(|\\phi^+\\rangle\\). We can implement this using Qiskitâ€™s QuantumCircuit class:\n\nbell = QuantumCircuit(2)\n\nbell.h(0) # apply an H gate to the circuit\nbell.cx(0,1) # apply a CNOT gate to the circuit\n\nbell.draw(output=\"mpl\")\n\nMatplotlib is building the font cache; this may take a moment.\n\n\n\n\n\nIf we want to check what the matrix representation is of this quantum state we can convert the circuit directly to an operator:\n\nbell_op = Operator(bell)\n\narray_to_latex(bell_op)\n\n$$\n\\[\\begin{bmatrix}\n\\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2} & 0 & 0  \\\\\n0 & 0 & \\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2}  \\\\\n0 & 0 & \\frac{\\sqrt{2}}{2} & \\frac{\\sqrt{2}}{2}  \\\\\n\\frac{\\sqrt{2}}{2} & - \\frac{\\sqrt{2}}{2} & 0 & 0  \\\\\n\\end{bmatrix}\\]\n$$\n\n\n\nEx 8 - the GHZ state is similar to the Bell State but applied to 3 qubits. Create a quantum circuit outputting the GHZ state\n\n\nghz = QuantumCircuit(3)\n\n##############################\n# add gates to your circuit here\nghz.h(0)\nghz.cx(0, 1)\nghz.cx(0, 2)\n\n\n\n##############################\n\nghz.draw(output='mpl')\n\n\n\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex8\n\ngrade_lab1_ex8(ghz)\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Dirac/lab1.html#measuring-quantum-states",
    "href": "posts/Dirac/lab1.html#measuring-quantum-states",
    "title": "Dirac Notation and Quantum Circuits",
    "section": "Measuring Quantum states",
    "text": "Measuring Quantum states\nAs explained in the lectures you can find the probability of measurement outcomes by taking the absolute value squared of the entries of a quantum state vector.\nFor example, when measuring the + state:\n$ |+= |0+ |1$\nThe probability of measuring 0 or 1 is given by the following:\n$ Pr(0) = ||^2 = $\n$ Pr(1) = ||^2 = $\nLetâ€™s create a \\(|+\\rangle\\) using the Statevector class:\n\nplus_state = Statevector.from_label(\"+\")\n\nplus_state.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |0\\rangle+\\frac{\\sqrt{2}}{2} |1\\rangle\\]\n\n\n\nplus_state\n\nStatevector([0.70710678+0.j, 0.70710678+0.j],\n            dims=(2,))\n\n\nNow we can get the probability of measuring 0 or 1:\n\nplus_state.probabilities_dict()\n\n{'0': 0.4999999999999999, '1': 0.4999999999999999}\n\n\nThe dictionary object above shows you all the possible measurement outcomes and what the probability is of getting them. The actual act of measuring forces the state to collapse into either the 0 or 1 state:\n\n# run this cell multiple times to show collapsing into one state or the other\nres = plus_state.measure()\n\nres\n\n('0',\n Statevector([1.+0.j, 0.+0.j],\n             dims=(2,)))\n\n\nWe can implement the same \\(|+\\rangle\\) state with measurement using a quantum circuit:\n\nqc = QuantumCircuit(1,1)\nqc.h(0)\nqc.measure(0, 0)\n\nqc.draw(output=\"mpl\")\n\n\n\n\nIf we ran this circuit using a simulator we would get the same results as we did with the statevector class.\nIn the next example, letâ€™s use the Statevector class to find the measurement outcomes for a dependent, probabilistic state. Weâ€™ll find the measurement probilities for the 2-qubit Bell State \\(|\\phi^+\\rangle\\) :\n\nsv_bell = Statevector([np.sqrt(1/2), 0, 0, np.sqrt(1/2)])\n\nsv_bell.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |00\\rangle+\\frac{\\sqrt{2}}{2} |11\\rangle\\]\n\n\n\nsv_bell.probabilities_dict()\n\n{'00': 0.5000000000000001, '11': 0.5000000000000001}\n\n\n\nEx 9 - Using the Statevector class find the probabilities for the other 3 states in the Bell Basis: \\(|\\psi^+\\rangle\\), \\(|\\psi^-\\rangle\\), \\(|\\phi^-\\rangle\\). Hint: check out lesson 2 to refresh your memory on the equations of the Bell states\n\n\nsv_psi_plus = Statevector([0,np.sqrt(1/2), np.sqrt(1/2), 0])# create a statevector for |ðœ“+âŸ© here\nprob_psi_plus =sv_psi_plus.probabilities_dict() # find the measurement probabilities for |ðœ“+âŸ© here\n\nsv_psi_minus = Statevector([0,np.sqrt(1/2), -np.sqrt(1/2), 0])# create a statevector for |ðœ“âˆ’âŸ© here\nprob_psi_minus = sv_psi_minus.probabilities_dict()# find the measurement probabilities for |ðœ“âˆ’âŸ© here\n\nsv_phi_minus = Statevector([np.sqrt(1/2), 0, 0, -np.sqrt(1/2)])# create a statevector for |ðœ™âˆ’âŸ© here\nprob_phi_minus = sv_phi_minus.probabilities_dict()# find the measurement probabilities for |ðœ™âˆ’âŸ© here\n\n\nfrom qc_grader.challenges.qgss_2023 import grade_lab1_ex9\n\ngrade_lab1_ex9([prob_psi_plus, prob_psi_minus, prob_phi_minus])\n\nSubmitting your answer. Please wait...\nCongratulations ðŸŽ‰! Your answer is correct and has been submitted."
  },
  {
    "objectID": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html",
    "href": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html",
    "title": "Heisenbergâ€™s Uncertainty Principle",
    "section": "",
    "text": "What did Heisenberg really mean by the uncertainty principle?\nThe most popular form of the uncertainty principle is about position and momentum of a particule, if one is know the other is uncertain; We will examine the same but not the momentum and position but using different basis of measures.\nfrom qiskit import QuantumCircuit, assemble, Aer\nfrom math import pi, sqrt\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nsim = Aer.get_backend('aer_simulator')\n# Let's do an X-gate on a |0&gt; qubit\nqc = QuantumCircuit(1)\nqc.x(0)\nqc.draw()\n\n   â”Œâ”€â”€â”€â”\nq: â”¤ X â”œ\n   â””â”€â”€â”€â”˜\n# Let's see the result\nqc.save_statevector()\nstate = sim.run(qc).result().get_statevector()\nplot_bloch_multivector(state)\nThe state hs been changed from 0 to 1, thats what X gate does\nqc.y(0) # Do Y-gate on qubit 0\nqc.z(0) # Do Z-gate on qubit 0\nqc.draw()\n\n   â”Œâ”€â”€â”€â” statevector â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”\nq: â”¤ X â”œâ”€â”€â”€â”€â”€â”€â–‘â”€â”€â”€â”€â”€â”€â”¤ Y â”œâ”¤ Z â”œ\n   â””â”€â”€â”€â”˜      â–‘      â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜\n# Create the X-measurement function:\ndef x_measurement(qc, qubit, cbit):\n    \"\"\"Measure 'qubit' in the X-basis, and store the result in 'cbit'\"\"\"\n    qc.h(qubit)\n    qc.measure(qubit, cbit)\n    return qc\n\ninitial_state = [1/sqrt(2), -1/sqrt(2)]\n# Initialize our qubit and measure it\nqc = QuantumCircuit(1,1)\nqc.initialize(initial_state, 0)\nx_measurement(qc, 0, 0)  # measure qubit 0 to classical bit 0\nqc.draw()\n\n     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”\n  q: â”¤ Initialize(0.70711,-0.70711) â”œâ”¤ H â”œâ”¤Mâ”œ\n     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â•¥â”˜\nc: 1/â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•\n                                           0\ncounts = sim.run(qc).result().get_counts()  # Do the simulation, returning the state vector\nplot_histogram(counts)  # Display the output on measurement of state vector\nWe initialized our qubit in - the state , but we can see that, after the measurement, we have collapsed our qubit to the 1 state . If you run the cell again, you will see the same result, since along the X-basis, the state - is a basis state and measuring it along X will always yield the same result.\nMeasuring in different bases allows us to see Heisenbergâ€™s famous uncertainty principle in action. Having certainty of measuring a state in the Z-basis removes all certainty of measuring a specific state in the X-basis, and vice versa. A common misconception is that the uncertainty is due to the limits in our equipment, but here we can see the uncertainty is actually part of the nature of the qubit."
  },
  {
    "objectID": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html#heisenbergs-uncertainty-principle",
    "href": "posts/Heisenberg/Single Qubit Gates and Heisenberg Principl.html#heisenbergs-uncertainty-principle",
    "title": "Heisenbergâ€™s Uncertainty Principle",
    "section": "Heisenbergâ€™s Uncertainty principle",
    "text": "Heisenbergâ€™s Uncertainty principle\nhttps://github.com/qiskit-community/qiskit-textbook/blob/main/content/ch-states/old-unique-properties-qubits.ipynb\n\nfrom qiskit import *\nfrom qiskit.visualization import plot_histogram\n%config InlineBackend.figure_format = 'svg' # Makes the images look nice\n\n\nmeasure_z = QuantumCircuit(1,1)\nmeasure_z.measure(0,0)\n\nmeasure_z.draw(output='mpl')\n\n\n\n\n\nmeasure_x = QuantumCircuit(1,1)\nmeasure_x.h(0)\nmeasure_x.measure(0,0)\n\nmeasure_x.draw(output='mpl')\n\n\n\n\n\nqc_0 = QuantumCircuit(1)\n\nqc_0.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_z, qc_0)\n\nqc.draw()\n\n     â”Œâ”€â”\n  q: â”¤Mâ”œ\n     â””â•¥â”˜\nc: 1/â•â•©â•\n      0 \n\n\n\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\n\n\ncounts\n\n{'0': 1024}\n\n\n\nprint('Results for z measurement:')\n\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(measure_x, qc_0)\nsim = Aer.get_backend('aer_simulator')\ncounts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     â”Œâ”€â”€â”€â”â”Œâ”€â”\n  q: â”¤ H â”œâ”¤Mâ”œ\n     â””â”€â”€â”€â”˜â””â•¥â”˜\nc: 1/â•â•â•â•â•â•â•©â•\n           0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\n\nqc_plus = QuantumCircuit(1)\nqc_plus.h(0)\n\nqc_plus.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_z)\n\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     â”Œâ”€â”€â”€â”â”Œâ”€â”\n  q: â”¤ H â”œâ”¤Mâ”œ\n     â””â”€â”€â”€â”˜â””â•¥â”˜\nc: 1/â•â•â•â•â•â•â•©â•\n           0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_plus, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n\n     â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”\n  q: â”¤ H â”œâ”¤ H â”œâ”¤Mâ”œ\n     â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â•¥â”˜\nc: 1/â•â•â•â•â•â•â•â•â•â•â•â•©â•\n                0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two.\n\nOther rotations\n\nqc_y = QuantumCircuit(1)\nqc_y.ry( -3.14159/4,0)\n\nqc_y.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit.compose(qc_y, measure_z)\n\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”\n  q: â”¤ Ry(-0.7854) â”œâ”¤Mâ”œ\n     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â•¥â”˜\nc: 1/â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•\n                     0 \n\n\n\nprint('Results for z measurement:')\nplot_histogram(counts)\n\nResults for z measurement:\n\n\n\n\n\nHere we have a case that we have not seen before. The z measurement is most likely to output 0, but it is not completely certain. A similar effect is seen below for the x measurement: it is most likely, but not certain, to output 1.\n\nqc = QuantumCircuit.compose(qc_y, measure_x)\ncounts = counts = sim.run(qc).result().get_counts()\nqc.draw()\n\n     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”â”Œâ”€â”\n  q: â”¤ Ry(-0.7854) â”œâ”¤ H â”œâ”¤Mâ”œ\n     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â•¥â”˜\nc: 1/â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•\n                          0 \n\n\n\nprint('Results for x measurement:')\nplot_histogram(counts)\n\nResults for x measurement:\n\n\n\n\n\nThese results hint at an important principle: Qubits have a limited amount of certainty that they can hold. This ensures that, despite the different ways we can extract outputs from a qubit, it can only be used to store a single bit of information. In the case of the blank circuit, this certainty was dedicated entirely to the outcomes of z measurements. For the circuit with a single Hadamard, it was dedicated entirely to x measurements. In this case, it is shared between the two."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "|quantum learnings>",
    "section": "",
    "text": "Dirac Notation and Quantum Circuits\n\n\n\n\n\n\n\nquantum theory\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nJul 17, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\n  \n\n\n\n\nHeisenbergâ€™s Uncertainty Principle\n\n\n\n\n\n\n\nquantum theory\n\n\n\n\n\n\n\n\n\n\n\nJun 12, 2023\n\n\nPrashant Mudgal\n\n\n\n\n\n\nNo matching items"
  }
]